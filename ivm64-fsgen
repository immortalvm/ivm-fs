#!/bin/bash

# Preservation Virtual Machine Project
#
# This static filesystem generator allows to recreate a folderless
# read/write static filesystem for testing the ivm64 ecosystem.
#
# By invoking the script with the list of files to include in the filesystem,
# it will print to stdout a C code with the file contents and some primitives
# (open, read, lseek) to access the files:
#
#    ivmfs-gen.sh file1.c file2.c ... > ivmfs.c
#
# Note: if the file name includes paths to directories they are
# considered part of the name (i.e. if you use "ivm64-fsgen /path/to/file"
# you need to open it as 'open("/path/to/file"...)'
#
# Note that files or directories are added individually to the filesystem and,
# therefore, to add a folder recursively you may wish to do:
#
#     ivm64-fsgen $(find folder_name) ... > ivmfs.c
#
# Then you can link a program with the generated C file, so that the primitives
# included in it will replace those of newlib, therefore enabling to access the
# files in a stardard way:
#
#     ivm64-gcc main.c ivmfs.c   # Always compile ivmfs.c before libraries
#
# where main.c can be like this:
#
#    main(){
#      FILE *f = fopen("file1.txt", "r");
#      int n = fread(buff, 1, 5, f);
#      ...
#     }
#
# By default, file data contents are generated by initializing a static array.
# However, data can be generated directly in ivm64 assembly object format which
# does not need to be compiled (only linked).
# To this end, invoke this script with "-o out.o" as first two arguments:
#
#     ivm64-fsgen -o out.o $(find folder_name) # assembly object 'out.o' is generated
#                                              # with the filesystem in it
#
# In case of very large filesystem (>4GB), it is recommended to generate data in
# assembly object format, and link it directly with the rest of the project:
#     # Directly, generate the assembly object with the files of interest:
#        ivm64-fsgen -o ivmfs-large.o $(find folder_name_with_very_large_files)
#     # Optionally, generate an empty filesystem (in C, contaning fs primitives):
#        ivm64-fsgen > ivmfs-empty.c
#     # Link ivmfs-large.o  with the rest of the project (optional with an empty fs)
#     # Do not forget to place the object with the FS in the first place
#        ivm64-gcc ivmfs-large.o ivmfs-empty.c main.c ....
#
# Debugging options:
#
#    ivm64-gcc -DIVMFS_DEBUG ivmfs.c ....
#        -> print information for each file operation
#
#    ivm64-gcc -DIVMFS_DUMPFILES ivmfs.c ....
#        -> dump a list of files when the program exits
#
#    ivm64-gcc -DIVMFS_DUMPFILECONTENTS ivmfs.c ....
#        -> dump the contents of all files when the program exits
#
# Authors:
#  Eladio Gutierrez Carrasco
#  Sergio Romero Montiel
#  Oscar Plata Gonzalez
#  * University of Malaga
#
# Date: Ago 2020 - Apr 2024

#cmdline="`basename $0` $@"
cmdname="`basename $0`"
print_header(){
    cat << EEOOPP
/*
 * iVM/iDA Preservation Virtual Machine Projects
 *
 * To be linked with the rest of the C files before libraries
 */

EEOOPP
}

init() {
    export IVMFS_ROOT="/work"
    export IVMFS_OUT_OBJ=
    export GLOBAL_FILETABLE=__IVM64_directory0__
    export GLOBAL_NFILES=__IVM64_nfiles0__

    # Initial directories
    ROOT="/"
    TMPDIR="/tmp"
    DEVDIR="/dev"
    IVMFSROOT=$IVMFS_ROOT

    # This file emulates standar input
    STDIN_EMU_NAME="stdin"
    STDIN_FILENAME="$IVMFSROOT""/""$STDIN_EMU_NAME"

    # Name assigned to temporal files
    UNNAMED_NAME="***unnamed***"

    # Standard IO devices
    STDIN_NAME="stdin"
    STDOUT_NAME="stdout"
    STDERR_NAME="stderr"

    STDIN_DEVICE="$DEVDIR""/""$STDIN_NAME"
    STDOUT_DEVICE="$DEVDIR""/""$STDOUT_NAME"
    STDERR_DEVICE="$DEVDIR""/""$STDERR_NAME"

    # Other useful char devices
    NULL_NAME="null"
    ZERO_NAME="zero"
    YES_NAME="yes"

    NULL_DEVICE="$DEVDIR""/""$NULL_NAME"
    ZERO_DEVICE="$DEVDIR""/""$ZERO_NAME"
    YES_DEVICE="$DEVDIR""/""$YES_NAME"

    # Special IO char devices
    BYTES_NAME="bytes"
    SAMPLE_NAME="sample"
    FRAMEOUT_NAME="frameout"

    SAMPLE_DEVICE="$DEVDIR""/""$SAMPLE_NAME"
    BYTES_DEVICE="$DEVDIR""/""$BYTES_NAME"
    FRAMEOUT_DEVICE="$DEVDIR""/""$FRAMEOUT_NAME"

    # Special IO block devices
    FRAMEIN_NAME="framein"
    PIXELIN_NAME="pixelin"
    PIXELOUT_NAME="pixelout"
    PIXELOUT_NAME4="pixelout4"
    PIXELOUT_NAME2="pixelout2"
    PIXELOUT_NAME1="pixelout1"

    FRAMEIN_DEVICE="$DEVDIR""/""$FRAMEIN_NAME"
    PIXELIN_DEVICE="$DEVDIR""/""$PIXELIN_NAME"
    PIXELOUT_DEVICE="$DEVDIR""/""$PIXELOUT_NAME"
    PIXELOUT_DEVICE4="$DEVDIR""/""$PIXELOUT_NAME4"
    PIXELOUT_DEVICE2="$DEVDIR""/""$PIXELOUT_NAME2"
    PIXELOUT_DEVICE1="$DEVDIR""/""$PIXELOUT_NAME1"
}

print_usage(){
    cat << UUSSEE
Usage:
    $cmdname file1 file2 .... > ivmfs.c
    $cmdname -o out.obj file1 file2 ...
UUSSEE
}

parse_args(){
    # If called as "ivm64-fgsen -o out.o ...."
    # generate assembly object 'out.o'
    export IVMFS_OUT_OBJ=
    if test "$1" == "-o"; then
        if ! test -z "$2"; then
            IVMFS_OUT_OBJ="$2"
        else
            1>&2 print_usage
            exit 1
        fi
    fi
}

printing_asm() {
    # Return true if printing assembly object
    # instead of C
    ! test -z "$IVMFS_OUT_OBJ" && return 0
    return 1
}

print_preamble() {
    cat << EEOOPP
#ifdef __ivm64__

#ifdef __cplusplus
extern "C" {
#endif

#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>
#include <stdarg.h>
#include <string.h>
#include <libgen.h>
#include <utime.h>
#include <termios.h>
#include <ioctl.h>

// DIRECTORIES
#define ROOT "$ROOT"
#define TMPDIR "$TMPDIR"
#define DEVDIR "$DEVDIR"
// The default initial current directory
#define IVMFSROOT "$IVMFSROOT"

// This file will emulate STDIN
#define STDIN_FILENAME "$STDIN_FILENAME"

// Name assigned to temporal files
#define UNNAMED_NAME "$UNNAMED_NAME"

// standard input/output
#define STDIN_FILENO  0
#define STDOUT_FILENO 1
#define STDERR_FILENO 2
#define FIRST_FILENO  3

// Max number of symbolic link hops to be taken before returning error ELOOP
#define MAX_LOOP 30

#ifndef TERMINAL_COLORS
#define TERMINAL_COLORS 0
#endif
// Set this to 1 to make read() emulate some tty features
// (echo, cannonical mode)
#ifndef IVM_TERMIOS
#define IVM_TERMIOS 1
#endif
// To be used by termios related stuff
#define TTYLINESIZE (16*1024)



////////////////////////////////////////////////////////////////////////////////
// strdup is not a standard C function; it may fail if compiler
// is asked to be strict C compliant (e.g., -std=c++14)
char* strdup(const char* s);

// second way to deal with strdup
//~ #define strdup(buf) strcpy((char*)malloc(strlen(buf)+1), buf)
//~ #undef strdup
////////////////////////////////////////////////////////////////////////////////







// Some extra macros and flags. See newlib/libc/include/sys/_default_fcntl.h
#define __set_errno(val) (*filesystem->errno_p = (val))
#define __get_errno() (*filesystem->errno_p)
#ifndef O_TMPFILE
#define O_TMPFILE       0x800000
#endif
#ifndef O_PATH
#define O_PATH          0x2000000
#endif
#define AT_EMPTY_PATH          16



// When the file grows a multiple of this is allocated 
#define BLKSIZE 64

// Allocate these extra blocks when writting
#define EXTRABLKS 8 

// MAX/MIN only one evaluation
#define MIN(a,b) ({ __typeof__(a) _a=(a);\\
                    __typeof__(b) _b=(b);\\
                    (_a < _b)?_a:_b;    })
#define MAX(a,b) ({ __typeof__(a) _a=(a);\\
                    __typeof__(b) _b=(b);\\
                    (_a > _b)?_a:_b;})




////////////////////////////////////////////////////////////////////////////////
// DEBUGGING STUFF
////////////////////////////////////////////////////////////////////////////////

// error messages without stderr
extern int printk(const char *format, ...);

#ifdef IVMFS_DUMPFILECONTENTS
#define IVMFS_DUMPFILES
#endif

#ifdef IVMFS_DEBUG_VERBOSE
    #define IVMFS_DEBUG
#endif

#ifdef IVMFS_DEBUG
    int __ivm64_debug_tab__ = 0;
    #define DEBUG_TAB_WIDTH 2
    #define DEBUG_TAB_INC do{__ivm64_debug_tab__+=DEBUG_TAB_WIDTH;}while(0)
    #define DEBUG_TAB_DEC do{if (__ivm64_debug_tab__>=DEBUG_TAB_WIDTH) __ivm64_debug_tab__-=DEBUG_TAB_WIDTH;}while(0)
    #define DEBUG_PRINT_TAB(n) do{ for(int i = 0; i < n; i++) printk(" "); }while(0)
    #define DEBUG_ENTRY_CODE(CODE) do{DEBUG_TAB_INC; CODE;}while(0)
    #define DEBUG_EXIT_CODE(CODE)  do{CODE; DEBUG_TAB_DEC;}while(0)
    #define DEBUG_PRINT(...) do{DEBUG_PRINT_TAB(__ivm64_debug_tab__); printk("[%s at %d] ",__func__, __LINE__); printk(__VA_ARGS__);}while(0)
    #ifdef IVMFS_DEBUG_VERBOSE
        #define DEBUG_ENTRY DEBUG_ENTRY_CODE(DEBUG_PRINT_TAB(__ivm64_debug_tab__); printk("[%s] ENTRY\n",__func__);)
        #define DEBUG_EXIT  DEBUG_EXIT_CODE(DEBUG_PRINT_TAB(__ivm64_debug_tab__); printk("[%s] EXIT\n",__func__);)
        #define DEBUG_PRINT_VERBOSE DEBUG_PRINT
    #else
        #define DEBUG_ENTRY DEBUG_ENTRY_CODE()
        #define DEBUG_EXIT  DEBUG_EXIT_CODE()
        #define DEBUG_PRINT_VERBOSE(...)
    #endif
    #define DEBUG_COND_PRINT(c,...) do{ if (c) { DEBUG_PRINT(__VA_ARGS__); } }while(0)

    // debugging, warn on strdup
    #define strdup(buf)\\
        ({\\
            size_t len = strnlen(buf, PATH_MAX);\\
            if (len > PATH_MAX) printk("[%s at %d] DUPLICATING STRING %ld\n",\\
                                        __func__, __LINE__, len);\\
            strcpy((char*)malloc(len+1), buf);\\
        })
#else
    #define DEBUG_PRINT_VERBOSE(...)
    #define DEBUG_COND_PRINT(c,...)
    #define DEBUG_PRINT(...)
    #define DEBUG_ENTRY
    #define DEBUG_EXIT
#endif
////////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////
// filesystem data structures (filetable)
////////////////////////////////////////////////////////////////////////////////
typedef struct {
    unsigned long size;
    unsigned long allocated;
    long links;             // number of hardlinks to this inode (used as pointer, see push/pop inode)
    char *data;
    mode_t mode;            // 0754 -> rwxr-xr--
    unsigned int inodeFixed;// If 1, do not free this struct
    unsigned int dataFixed; // If 1, do not free data
} inode_t;

typedef struct {            // entry in directory
    char* pathname;         // the fullpath of the file
    inode_t *inode;         // pointer to the inode of the file
    long links;             // number of file descriptors with this entry in use
} dentry_t;

typedef struct {
    unsigned long nfiles;   // Files initially in the filesystem
    unsigned long allocated;
    dentry_t *directory;    // The current filesystem table
    long last_dentry_idx;
    inode_t *inode_free_list;
} filesystem_data_t;

typedef struct {            // Open file description structure
   long idx;                // Entry in Filetable/Directory (dentry_t)
   unsigned long pos;       // position -> read, write, lseek,...
   unsigned int flags;      // flags passed to open: access mode, append,...
   unsigned int links;      // number of file descriptors using this description (dup, dup2)
   inode_t *inode;          // redundant, also accessed via directory[idx]
} file_t;

typedef struct {
    unsigned long size;     // size of openfile table
    file_t **fd;            // Open files table
} filesystem_file_t;

typedef struct {            // Current working directory
    char *soft;             // The cwd in the user view (softlinks dirs)
    char *real;             // The cwd in the real path space
} filesystem_cwd_t;

typedef struct {            // Spawn programs use these pointers to work in host program space
    void (*_cleanupdir)(DIR *dirp);
    void (*_seekdir)(DIR *dirp, long loc);
    int (*chdir)(const char *path);
    int (*close)(int fd);
    int (*dup)(int oldfd);
    int (*dup2)(int oldfd, int newfd);
    int (*faccessat)(int dirfd, const char *pathname, int mode, int flags);
    int (*fchdir)(int fd);
    int (*fchmod)(int fd, mode_t mode);
    int (*fchmodat)(int dirfd, const char *pathname, mode_t mode, int flags);
    int (*fcntl)(int fd, int cmd, va_list arg);
    int (*fdatasync)(int fd);
    int (*fstat)(int fd, struct stat *st);
    int (*fstatat)(int dirfd, const char *pathname, struct stat *statbuf, int flags);
    int (*fsync)(int fd);
    int (*ftruncate)(int fd, off_t length);
    char* (*getcwd)(char *buf, size_t size);
    long (*getdents)(int fd, struct dirent *dirp, size_t count);
    int (*ioctl)(int fd, unsigned long request, va_list arg);
    int (*isatty)(int fd);
    int (*link)(const char *oldpath, const char *newpath);
    int (*linkat)(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags);
    off_t (*lseek)(int file, off_t offset, int whence);
    int (*lstat)(const char *pathname, struct stat *st);
    int (*openat)(int dirfd, const char *pathname, int flags, ...);
    ssize_t (*read)(int fd, void *buf, size_t count);
    struct dirent* (*readdir)(DIR *dirp);
    ssize_t (*readlinkat)(int dirfd, const char *pathname, char *buf, size_t bufsiz);
    char* (*realpath)(const char *pathname, char *canon_name);
    int (*renameat)(int olddirfd, const char *oldpath, int newdirfd, const char *newpath);
    int (*rmdir)(const char *pathname);
    int (*stat)(const char *file, struct stat *st);
    int (*symlinkat)(const char *target, int newdirdf, const char *linkpath);
    long (*telldir)(DIR *dirp);
    int (*truncate)(const char *path, off_t length);
    mode_t (*umask)(mode_t mask);
    int (*unlinkat)(int dirfd, const char *pathname, int flags);
    int (*utime)(const char *filename, const struct utimbuf *times);
    int (*utimes)(const char *filename, const struct timeval times[2]);
    ssize_t (*write)(int fd, const void *buf, size_t count);
} filesystem_oper_t;

typedef struct {            // Spawn programs use this structure to work in host program space
    filesystem_oper_t oper; // all filesystem operations
    filesystem_data_t data; // file table
    filesystem_file_t fd;   // open files
    filesystem_cwd_t  cwd;  // Current work directory
    struct termios tty_termios;
    mode_t umask;
    int * errno_p;
} filesystem_t;


EEOOPP
}




print_files() {
    if ! which hexdump >& /dev/null; then
        >&2 echo "hexdump not found; it is required by this script"
        exit 1
    fi

    # Functions to generate C code for static array initialization with the file content
    # Dump 8-byte words (hexdump not supporting 16/8, so concatenating parts with sed)
    hdf() { hexdump -v -e '16/4 "0x%08x, " "\n"' < "$1" | sed -E 's/, 0x +//g' | sed -E 's/0x([0-9a-f]+)\s*,\s*0x([0-9a-f]+)/0x\2\1/g'; }
    # The same, but with some unrolling for higher performance
    hdf8n() { hexdump -v -e '16/4 "%08x " "\n"' < "$1" |
              gawk '{
                      if (length($2 )) {printf "0x%s%s, ",  $2, $1;}  else {printf "0x00000000%s, ", $1}
                      if (length($4 )) {printf "0x%s%s, ",  $4, $3;}  else {printf "0x00000000%s, ", $3}
                      if (length($6 )) {printf "0x%s%s, ",  $6, $5;}  else {printf "0x00000000%s, ", $5}
                      if (length($8 )) {printf "0x%s%s, ",  $8, $7;}  else {printf "0x00000000%s, ", $7}
                      if (length($10)) {printf "0x%s%s, ", $10, $9;}  else {printf "0x00000000%s, ", $9}
                      if (length($12)) {printf "0x%s%s, ", $12, $11;} else {printf "0x00000000%s, ", $11}
                      if (length($14)) {printf "0x%s%s, ", $14, $13;} else {printf "0x00000000%s, ", $13}
                      if (length($16)) {printf "0x%s%s,",  $16, $15;} else {printf "0x00000000%s,",  $15}
                      print ""
                    }'  ;
            }
    hdf() { hdf8n "$@" ; }

    # Functions to generate file contents as embedded ivm64 asm
    hdf8n_list() { hexdump -v -e '16/4 "%08x " "\n"' < "$1" |
              gawk '{
                      if (length($2 )) {printf "0x%s%s ",  $2, $1;}  else {printf "0x00000000%s ", $1}
                      if (length($4 )) {printf "0x%s%s ",  $4, $3;}  else {printf "0x00000000%s ", $3}
                      if (length($6 )) {printf "0x%s%s ",  $6, $5;}  else {printf "0x00000000%s ", $5}
                      if (length($8 )) {printf "0x%s%s ",  $8, $7;}  else {printf "0x00000000%s ", $7}
                      if (length($10)) {printf "0x%s%s ", $10, $9;}  else {printf "0x00000000%s ", $9}
                      if (length($12)) {printf "0x%s%s ", $12, $11;} else {printf "0x00000000%s ", $11}
                      if (length($14)) {printf "0x%s%s ", $14, $13;} else {printf "0x00000000%s ", $13}
                      if (length($16)) {printf "0x%s%s ", $16, $15;} else {printf "0x00000000%s ", $15}
                      print ""
                    }'  ;
            }
    hdf8n_asm() { hdf8n_list "$@" | gawk '{ print "data8 [" $0 "]"}' ; }
    hdf_asm() { hdf8n_asm "$@" ; }

    # Function to print a string in asm
    asm_str(){ echo -n "$1" | hexdump -v -e '1/1 "%d" " "' | gawk '{ print "data1 [" $0 0 "]"}' ; }

    # Function to print the string to be used as filename in a table file entyr
    # Usage:
    #        asm_string label string
    asm_string(){
        # $1=label, $2=string
        # Note that eventually this string must be print with "echo -e"
        # to parse \n as newlines
        echo -n "$1:\n#\t.string \"${2}\"\n\t$(asm_str "$2")"
    }

    # Associative arrays for file table entries
    declare -A inode_entry
    declare -A file_entry
    declare -A dir_entry

    # An associative array with the files already processed
    declare -A seenfile

    # An associative array for extern clauses with the label named associated
    # to file data
    declare -A asmfilenamestr

    nf=0
    nd=0
    nt=0

    # from gcc-12.2.0-ivm64/ivm64/include/sys/stat.h
    _IFDIR=0040000 #/* directory */
    _IFCHR=0020000 #/* character special */
    _IFBLK=0060000 #/* block special */
    _IFREG=0100000 #/* regular */
    _IFLNK=0120000 #/* symbolic link */


    # Function to set up inode_entry[], dir_entry[] (and asmfilenamestr[] if needed) for a DIRECTORY
    # Usage:
    #        filetable_dir_entry directory_name c_mode
    #                                  $1         $2
    filetable_dir_entry(){
        seenfile[$1]=1
        if printing_asm; then
            inodelabel=".LIVMFS_INODE${nt}.${ASM_DATA_OBJID}"
            filenamelabel=".LIVMFS_FN${nt}.${ASM_DATA_OBJID}"
            mode=$(( _IFDIR | $2 ))
            inode_entry[$nt]="$inodelabel:\n\tdata8 [0 0 1 0]\n\tdata4 [$mode 1 1 0]"
            asmfilenamestr[$nt]=$(asm_string $filenamelabel $1)
            dir_entry[$nd]="data8 [$filenamelabel $inodelabel 0]\n"
        else
            inode_entry[$nt]="static inode_t inode${nt} = (inode_t){ 0, 0, 1, NULL, (S_IFDIR | $2), 1, 1 };"
            dir_entry[$nd]="{(char*)\"$1\", &inode${nt}, 0}"
        fi
        let nd=nd+1
        let nt=nt+1
    }       

    # Function to set up inode_entry[], dir_entry[] (and asmfilenamestr[] if needed) for a FILE
    # Usage:
    #        filetable_file_entry file_name file
    #                                $1      $2
    filetable_file_entry(){
        seenfile[$1]=1
        size=$(stat -c %s "$2")
        mode=$(stat -c %#a "$2") # mode in octal
        if printing_asm; then
            filedatalabel=".LIVMFS_FC${nt}.${ASM_DATA_OBJID}"
            inodelabel=".LIVMFS_INODE${nt}.${ASM_DATA_OBJID}"
            filenamelabel=".LIVMFS_FN${nt}.${ASM_DATA_OBJID}"
            echo -e "$filedatalabel:"
            hdf_asm "$2"
            mode=$(( $mode | _IFREG ))
            inode_entry[$nt]="$inodelabel:\n\tdata8 [$size $size 1 $filedatalabel]\n\tdata4 [$mode 1 1 0]"
            asmfilenamestr[$nt]=$(asm_string $filenamelabel $1)
            file_entry[$nf]="data8 [$filenamelabel $inodelabel 0]\n"
        else
            ptrname=content_of_file_${nt}
            echo "static uint64_t $ptrname[]={"
            hdf "$2"
            echo "};"
            inode_entry[$nt]="static inode_t inode${nt} = (inode_t){ $size, $size, 1, (char*)$ptrname, (S_IFREG | $mode), 1, 1 };"
            file_entry[$nf]="{(char*)\"$1\", &inode${nt}, 0}"
        fi
        let nf=nf+1
        let nt=nt+1
    }

    # Function to set up inode_entry[], dir_entry[] (and asmfilenamestr[] if needed) for a DEVICE
    # Usage:
    #        filetable_dev_entry file_var_name type mode c_var_string
    #                                  $1       $2   $3       $4
    filetable_dev_entry(){
        seenfile[$1]=1
        if printing_asm; then
            filedatalabel=".LIVMFS_FC${nt}.${ASM_DATA_OBJID}"
            inodelabel=".LIVMFS_INODE${nt}.${ASM_DATA_OBJID}"
            filenamelabel=".LIVMFS_FN${nt}.${ASM_DATA_OBJID}"
            mode=$(( ${!2} | $3 ))
            echo -e $(asm_string $filedatalabel "${!4}")
            inode_entry[$nt]="$inodelabel:\n\tdata8 [0 0 1 $filedatalabel]\n\tdata4 [$mode 1 1 0]"
            asmfilenamestr[$nt]=$(asm_string $filenamelabel ${!1})
            file_entry[$nf]="data8 [$filenamelabel $inodelabel 0]\n"
        else
            # Insert C macros for the device name/path
            echo "#define $4 \"${!4}\""
            echo "#define $1 \"${!1}\""
            mode="(S$2 | $3)"
            inode_entry[$nt]="static inode_t inode${nt} = (inode_t){ 0, 0, 1, $4, $mode, 1, 1 };"
            file_entry[$nf]="{(char*)$1, &inode${nt}, 0}"
        fi
        let nf=nf+1
        let nt=nt+1
    }

    # Function to set up inode_entry[], dir_entry[] (and asmfilenamestr[] if needed) for a DEVICE
    # Usage:
    #        filetable_lnk_entry file_name file
    #                                $1     $2
    filetable_lnk_entry(){
        seenfile[$1]=1
        size=$(( $(stat -c %s "$2") + 1))
        symlink=$(readlink "$2")
        if printing_asm; then
            filedatalabel=".LIVMFS_FC${nt}.${ASM_DATA_OBJID}"
            echo -e $(asm_string $filedatalabel $symlink)
            inodelabel=".LIVMFS_INODE${nt}.${ASM_DATA_OBJID}"
            filenamelabel=".LIVMFS_FN${nt}.${ASM_DATA_OBJID}"
            mode=$(( _IFLNK | 0777 ))           # mode 0777 for symlinks
            inode_entry[$nt]="$inodelabel:\n\tdata8 [$size $size 1 $filedatalabel]\n\tdata4 [$mode 1 1 0]"
            asmfilenamestr[$nt]=$(asm_string $filenamelabel $1)
            file_entry[$nf]="data8 [$filenamelabel $inodelabel 0]\n"
        else
            inode_entry[$nt]="static inode_t inode${nt} = (inode_t){ $size, $size, 1, \"$symlink\", (S_IFLNK | 0777), 1, 1 };"
            file_entry[$nf]="{(char*)\"$1\", &inode${nt}, 0}"
        fi
        let nf=nf+1
        let nt=nt+1
    }

    if printing_asm; then
        export ASM_DATA_OBJID=oivmfs$RANDOM
        cat << EEOOFF
##:ivm64:obj-id: $ASM_DATA_OBJID
# This is a GCC-generated ivm64 assembly object file

EEOOFF
    fi

    # Add always directories: "/", "/tmp", "/dev" & "/work"
    filetable_dir_entry $ROOT      0777
    filetable_dir_entry $TMPDIR    0777
    filetable_dir_entry $DEVDIR    0777
    filetable_dir_entry $IVMFSROOT 0777
    #
    # Char devices stdin, stdout, stderr, null, zero,...
    filetable_dev_entry STDIN_DEVICE     _IFCHR 0444 STDIN_NAME
    filetable_dev_entry STDOUT_DEVICE    _IFCHR 0222 STDOUT_NAME
    filetable_dev_entry STDERR_DEVICE    _IFCHR 0222 STDERR_NAME
    filetable_dev_entry NULL_DEVICE      _IFCHR 0666 NULL_NAME
    filetable_dev_entry ZERO_DEVICE      _IFCHR 0444 ZERO_NAME
    filetable_dev_entry YES_DEVICE       _IFCHR 0444 YES_NAME
    filetable_dev_entry BYTES_DEVICE     _IFCHR 0222 BYTES_NAME
    filetable_dev_entry SAMPLE_DEVICE    _IFCHR 0222 SAMPLE_NAME
    filetable_dev_entry FRAMEOUT_DEVICE  _IFCHR 0222 FRAMEOUT_NAME
    filetable_dev_entry FRAMEIN_DEVICE   _IFBLK 0444 FRAMEIN_NAME
    filetable_dev_entry PIXELIN_DEVICE   _IFBLK 0444 PIXELIN_NAME
    filetable_dev_entry PIXELOUT_DEVICE  _IFBLK 0222 PIXELOUT_NAME
    filetable_dev_entry PIXELOUT_DEVICE4 _IFBLK 0222 PIXELOUT_NAME4
    filetable_dev_entry PIXELOUT_DEVICE2 _IFBLK 0222 PIXELOUT_NAME2
    filetable_dev_entry PIXELOUT_DEVICE1 _IFBLK 0222 PIXELOUT_NAME1
    #

    while test $# -gt 0
    do
        # Get relative/absolute path
        if [[ "$1" =~ ^/.* ]]  ; then
            #Absolute name
            ivmfsroot=
            filename=$(realpath -m "$1")
        else
            basename=$(basename $1)
            dirname=$(dirname $1)
            rpath="$(realpath -m --relative-to=. "$dirname")"
            if [[ "$rpath" =~ ^\.\. ]] ; then
                #Filename not relative to ., absolutize it
                ivmfsroot=$(realpath -m $rpath)
            elif [[ "$rpath" =~ ^\. ]] ; then
                #Filename relative to .
                ivmfsroot=$IVMFSROOT
            else
                #Filename relative to .
                ivmfsroot=$IVMFSROOT"/"$rpath
            fi
            filename="$ivmfsroot""/""$basename"
        fi

        if ! test -z ${seenfile["$filename"]}; then
            # Do no process the same file twice
            shift
            continue
        fi



        if ! test -z "$1" && test -h "$1"
        # include symbolic links
        then
            size=$(stat -c %s "$1") # the size of a symbolic link does not include the nul terminator
            filetable_lnk_entry $filename $1
        elif ! test -z "$1" && test -f "$1"
        # include existing regular files whose name is not an empty string
        then
            filetable_file_entry $filename $1
        elif ! test -z "$1" && test -d "$1"
        # include directories
        then
            filetable_dir_entry $filename 0777
        else
            filetable_dir_entry $filename 0777
        fi

        seenfile["$filename"]=1

        # Traverse all dirs in the filename patand append them to the argument list,
        # to include also these dirs in the file system
        dirname="$(dirname "$filename")"
        dirlist=
        while test -z ${seenfile["$dirname"]} && [[ "$dirname" != "." ]] && [[ "$dirname" != "/" ]]
        do
            dirlist="$dirname $dirlist"
            dirname="$(dirname "$dirname")"
        done
        if ! test -z "${dirlist}"
        then
            set -- "$@" $dirlist
        fi
        shift
    done


    # For each file, generate a statement initializing the inode struct of type inode_t:
    #   // (size, allocated, attr, links, inodeFix, dataFix, data)
    #   { 5, 5, S_IFREG | 0640, 1, 1, 1, (char*)content_of_fileXX }
    #   { 0, 0, S_IFDIR | 0777, 1, 1, 1, NULL }
    #   { 5, 5, S_IFLNK | 0777, 1, 1, 1, "datao" }
    #   { 0, 0, S_IFCHR | 0444, 1, 1, 1, "stdin" }
    #   { 0, 0, S_IFBLK | 0666, 1, 1, 1, "frame" }
    # Print inodes
    for i in ${!inode_entry[@]}
    #~ for i in `seq 0 $(( $nt - 1 ))`
    do
        echo -e ${inode_entry[$i]}
    done

    # Number of entries (files+directories)
    n=$(($nf + $nd))

    # Print all initialization statements into one only array:
    #    static dentry_t directory0[NFILES] =
    #    {
    #        {"/",       &inode0, 0},
    #        {"/work",   &inode1, 0},
    #        ...    
    #        {"file8.txt", &inode8, 0},
    #        {"file9.txt", &inode9, 0},
    #        ...
    #    };
    #    static dentry_t *directory = directory0;

    # Fix a number of max files
    MAXFILES=$(($n))

    if printing_asm; then
        # Print the asm string for each existing file name
        for f in ${!asmfilenamestr[@]}
        #~ for ((f=0; f<$nt; f++))
        do
            echo -e ${asmfilenamestr[$f]}
        done
        echo

        # When printing data in asm format, the filetable pointer is the
        # only external (exported) label
        echo "## Initial filesystem table"
        echo "EXPORT ${GLOBAL_NFILES}"
        echo -e "${GLOBAL_NFILES}:\n   data8[$MAXFILES]"
        echo "EXPORT $GLOBAL_FILETABLE"
        echo "$GLOBAL_FILETABLE:"
    else
        # Starting table when printing C
        echo ''
        echo ''
        cat << EEOOFF
#ifndef NAME_MAX
#define NAME_MAX 256
#endif
#ifndef PATH_MAX
#define PATH_MAX 4096
#endif

#define MAX_FILES $MAXFILES
// Initial filesystem table"
volatile uint64_t ${GLOBAL_NFILES} = MAX_FILES;
dentry_t $GLOBAL_FILETABLE[MAX_FILES] = {
EEOOFF
    fi

    # First, print directories
    #~ for d in ${!dir_entry[@]}
    for ((d=0; d<$nd; d++))
    do
        echo -e -n '   ' ${dir_entry[$d]}
        ! printing_asm && echo ','
    done

    # Next, print regular files
    for f in ${!file_entry[@]}
    #~ for ((f=0; f<$nf; f++))
    do
        echo -e -n '   ' ${file_entry[$f]}
        ! printing_asm && echo ','
    done
    #echo '    {NULL, NULL, 0}'

    if ! printing_asm ; then
        # Closing table when printing C
        echo '};'
        echo ''
    fi
}

print_structure() {
    cat << EEOOFF

static void _cleanupdir0(DIR *dirp);
static void _seekdir0(DIR *dirp, long loc);
static int chdir0(const char *path);
static int close0(int fd);
static struct dirent* readdir0(DIR *dirp);
static int dup0(int oldfd);
static int dup20(int oldfd, int newfd);
static int faccessat0(int dirfd, const char *pathname, int mode, int flags);
static int fchdir0(int fd);
static int fchmod0(int fd, mode_t mode);
static int fchmodat0(int dirfd, const char *pathname, mode_t mode, int flags);
static int fcntl0(int fd, int cmd, va_list arg);
static int fdatasync0(int fd);
static int fstat0(int fd, struct stat *st);
static int fstatat0(int dirfd, const char *pathname, struct stat *statbuf, int flags);
static int fsync0(int fd);
static int ftruncate0(int fd, off_t length);
static char* getcwd0(char *buf, size_t size);
static long getdents0(int fd, struct dirent *dirp, size_t count);
static int ioctl0(int fd, unsigned long request, va_list arg);
static int isatty0(int fd);
static int linkat0(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags);
static off_t lseek0(int file, off_t offset, int whence);
static int openat0(int dirfd, const char *pathname, int flags, ...);
static ssize_t read0(int fd, void *vbuf, size_t len);
static ssize_t readlinkat0(int dirfd, const char *pathname, char *buf, size_t bufsiz);
static char* realpath0(const char *pathpath, char *resolved_path);
static int renameat0(int olddirfd, const char *oldpath, int newdirfd, const char *newpath);
static int symlinkat0(const char *target, int newdirfd, const char *linkpath);
static long telldir0(DIR *dirp);
static int truncate0(const char *path, off_t length);
static mode_t umask0(mode_t mask);
static int unlinkat0(int dirfd, const char *pathname, int flags);
static int utime0(const char *filename, const struct utimbuf *times);
static int utimes0(const char *filename, const struct timeval times[2]);
static ssize_t write0(int fd, const void *vptr, size_t nbytes);

static int errno0;

static filesystem_t filesystem0 = {
    oper: {
        _cleanupdir: _cleanupdir0,
        _seekdir: _seekdir0,
        chdir: chdir0,
        close: close0,
        dup: dup0,
        dup2: dup20,
        faccessat: faccessat0,
        fchdir: fchdir0,
        fchmod: fchmod0,
        fchmodat: fchmodat0,
        fcntl: fcntl0,
        fdatasync: fdatasync0,
        fstat: fstat0,
        fstatat: fstatat0,
        fsync: fsync0,
        ftruncate: ftruncate0,
        getcwd: getcwd0,
        getdents: getdents0,
        ioctl: ioctl0,
        isatty: isatty0,
        linkat: linkat0,
        lseek: lseek0,
        openat: openat0,
        read: read0,
        readdir: readdir0,
        readlinkat: readlinkat0,
        realpath: realpath0,
        renameat: renameat0,
        symlinkat: symlinkat0,
        telldir: telldir0,
        truncate: truncate0,
        umask: umask0,
        unlinkat: unlinkat0,
        utime: utime0,
        utimes: utimes0,
        write: write0,
    },
    data: {
        nfiles: 0,
        allocated: 0,
        directory: ${GLOBAL_FILETABLE},
        last_dentry_idx: -1,
        inode_free_list: NULL,
    },
    fd: {
        size: 0,
        fd: NULL,
    },
    cwd: {
        soft: NULL,
        real: NULL,
    },
    tty_termios: {},
    umask: 0,
    errno_p: &errno0,
};

static filesystem_t *filesystem = &filesystem0;
static long openfile_get_directory_entry(file_t *p)     {return (p->idx - 1);}
static unsigned long openfile_get_position(file_t *p)   {return p->pos;}
static unsigned int openfile_get_flags(file_t *p)       {return p->flags;}
static inode_t* openfile_get_inode(file_t *p)           {return p->inode;}
static void openfile_set_directory_entry(file_t *p, long idx)   {p->idx = idx + 1;}
static void openfile_set_position(file_t *p, unsigned long pos) {p->pos = pos;}
static void openfile_set_links(file_t *p, unsigned int links)   {p->links = links;}
static void openfile_set_flags(file_t *p, unsigned int flags)   {p->flags = flags;}
static void openfile_set_inode(file_t *p, inode_t *inode)       {p->inode = inode;}
static void openfile_link(file_t *p)                            {p->links++;}
static void openfile_unlink(file_t *p)              {if (!--p->links) free(p);}

static file_t *new_openfile(long idx, inode_t *inode_p, int flags)
{
    DEBUG_ENTRY;
    file_t *new_entry = (file_t *)malloc(sizeof(file_t));
    if (!new_entry) {
        __set_errno(ENOSPC);
        DEBUG_EXIT;
        return NULL;
    }
    openfile_set_directory_entry(new_entry, idx);
    openfile_set_position(new_entry, 0);
    openfile_set_flags(new_entry, flags);
    openfile_set_links(new_entry, 0);
    openfile_set_inode(new_entry, inode_p);
    DEBUG_EXIT;
    return new_entry;
}

#define OPENFILE_GET_INODE(file)\\
    ({\\
        inode_t *inode_p = openfile_get_inode(file);\\
        if (inode_p == NULL) {\\
            DEBUG_PRINT("failed (inode is nul)\n");\\
            DEBUG_EXIT;\\
            __set_errno(EIO);\\
            return -1;\\
        }\\
        inode_p;\\
    })
static char *inode_get_data(inode_t *ino)               {return ino->data;}
static void inode_set_data(inode_t *ino, char *data)    {ino->data = data;}
static ssize_t inode_get_size(inode_t *ino)             {return ino->size;}
static void inode_set_size(inode_t *ino, ssize_t size)  {ino->size = size;}
static ssize_t inode_get_allocated(inode_t *ino)        {return ino->allocated;}
static void inode_set_allocated(inode_t *ino, ssize_t allocated){ino->allocated = allocated;}
static mode_t inode_get_mode(inode_t *ino)              {return ino->mode;}
static void inode_set_mode(inode_t *ino, mode_t mode)   {ino->mode = mode; }
static long inode_get_links(inode_t *ino)               {return ino->links;}
static void inode_set_links(inode_t *ino, long links)   {ino->links = links;}
static inode_t* inode_dup(inode_t *ino)     {ino->links++; return ino;}

int inode_get_filetype(inode_t *ino)
{
    mode_t mode = inode_get_mode(ino);
    return  S_ISLNK(mode)? DT_LNK:
            S_ISDIR(mode)? DT_DIR:
            S_ISCHR(mode)? DT_CHR:
            S_ISBLK(mode)? DT_BLK:
            S_ISREG(mode)? DT_REG: DT_UNKNOWN;
}

static void push_inode(inode_t *ino)
{
    if (ino) {
        inode_set_links(ino, (long)filesystem->data.inode_free_list);
        filesystem->data.inode_free_list = ino;
    }
}

static inode_t* pop_inode()
{
    inode_t *last = filesystem->data.inode_free_list;
    if (last) {
        filesystem->data.inode_free_list = (inode_t*)inode_get_links(last);
    }
    return last;
}

static inode_t* new_inode(mode_t mode)
{
    DEBUG_ENTRY;
    inode_t *inode_p = pop_inode();
    if (!inode_p) {
        inode_p = (inode_t*)malloc(sizeof(inode_t));
        if (!inode_p) {
            DEBUG_PRINT("failed (not memory for new inode)\n");
            DEBUG_EXIT;
            __set_errno(ENOMEM);
            return NULL;
        }
        inode_p->inodeFixed = 0;
        inode_p->dataFixed = 0;
        inode_p->data = NULL;
        inode_p->allocated = 0;
    }

    inode_p->mode = mode;
    inode_p->links = 1;
    inode_p->size = 0;

    DEBUG_PRINT("[%p] size=%ld alloc=%ld type=%s mode=%#o links=%d ino_fixed=%d data_fixed=%d data=%p\n",
            inode_p, inode_p->size, inode_p->allocated,
            S_ISLNK(mode)? "LNK": S_ISDIR(mode)? "DIR": S_ISCHR(mode)? "CHR":
            S_ISBLK(mode)? "BLK": S_ISREG(mode)? "REG": "UNKNOWN",
            inode_p->mode, inode_p->links, inode_p->inodeFixed,
            inode_p->dataFixed, inode_p->data);

    DEBUG_EXIT;
    return inode_p;
}

static void free_inode(inode_t *inode_p)
{
    inode_p->mode = 0;
    inode_p->size = 0;
    inode_p->links = 0;
    if (!inode_p->dataFixed && inode_p->allocated) {
        inode_p->allocated = 0;
        free(inode_p->data);
        inode_p->data = NULL;
        if (! inode_p->inodeFixed) {
            free(inode_p);
            return;
        }
    }
    push_inode(inode_p);
}

static void inode_unlink(inode_t *ino)
{
    int links = inode_get_links(ino) - 1;
    if (links) inode_set_links(ino, links);
    else free_inode(ino);
}

static char* directory_get_pathname(long idx)
                        {return filesystem->data.directory[idx].pathname;}
static inode_t* directory_get_inode(long idx)
                        {return filesystem->data.directory[idx].inode;}
static void directory_set_pathname(long idx, char *pathname)
                        {filesystem->data.directory[idx].pathname = pathname;}
static void directory_set_inode(long idx, inode_t *inode_p)
                        {filesystem->data.directory[idx].inode = inode_p;}
static void directory_set_links(long idx, long links)
                        {filesystem->data.directory[idx].links = links;}
static long directory_get_links(long idx)
                        {return filesystem->data.directory[idx].links;}
static void directory_link(long idx)
                        {filesystem->data.directory[idx].links++;}
static long directory_unlink(long idx)
                        {return --filesystem->data.directory[idx].links;}

#define DIRECTORY_GET_INODE(idx)\\
    ({\\
        inode_t *inode_p = directory_get_inode(idx);\\
        if (inode_p == NULL) {\\
            DEBUG_PRINT("failed (inode is nul)\n");\\
            DEBUG_EXIT;\\
            __set_errno(EIO);\\
            return -1;\\
        }\\
        inode_p;\\
    })

static long directory_find_entry(const char* pathname)
{
    DEBUG_ENTRY;
    long idx;
    long nfiles = filesystem->data.nfiles;
    size_t len = strnlen(pathname, PATH_MAX);
    int localerr = ENOENT;
    for (idx = 0; idx < nfiles; idx++){
        char *refname = directory_get_pathname(idx);
        DEBUG_PRINT_VERBOSE("trying '%s' == '%s'\n", refname, pathname);
        if (!refname) continue;
        if (strlen(refname) < len) continue;
        if (strncmp(refname, pathname, len)) continue;
        if (refname[len] == '\0') break;
        if (refname[len-1] != '/' && refname[len] != '/') continue;
        localerr = 0;
    }
    if (idx == nfiles) {
        DEBUG_PRINT("not found '%s' (errno = %d -> 0 means found subentries)\n",
                                        pathname, localerr);
        DEBUG_EXIT;
        __set_errno(localerr);
        return -1;
    }
    DEBUG_PRINT("found '%s' -> idx=%ld / %ld\n", pathname, idx, nfiles);
    DEBUG_EXIT;
    return idx;
}

static long directory_find_subentry(const char* pathname, long init)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: '%s' from %ld\n", pathname, init);
    long nfiles = filesystem->data.nfiles;
    if (init >= nfiles) {
        DEBUG_PRINT("failed (no more entries %ld/%ld)\n", init, nfiles);
        DEBUG_EXIT;
        return -1;
    }
    if (pathname[0] != '/') {
        DEBUG_PRINT("failed ('%s' is not an absolute path)\n", pathname);
        DEBUG_EXIT;
        return -1;
    }
    if (pathname[1] == '\0') {
        DEBUG_PRINT("'%s' is root of all entries [%ld])\n", pathname, init);
        DEBUG_EXIT;
        return init;
    }
    if (init < 0) init = 0;
    size_t len = strnlen(pathname, PATH_MAX);
    long idx;
    for (idx = init; idx < nfiles; idx++){
        char *refname = directory_get_pathname(idx);
        DEBUG_PRINT_VERBOSE("trying with '%s'\n", refname);
        if (!refname) continue;
        if (strlen(refname) < len) continue;
        if (strncmp(refname, pathname, len)) continue;
        if (refname[len-1]!='/' && refname[len]!='/') continue;
        DEBUG_PRINT("found '%s' in '%s' idx=%ld\n", pathname, refname, idx);
        DEBUG_EXIT;
        return idx;
    }
    DEBUG_PRINT("not found '%s' (errno = %d ENOENT)\n", pathname, ENOENT);
    __set_errno(ENOENT);
    DEBUG_EXIT;
    return -1;
}

static dentry_t* reallocate_directory()
{
    DEBUG_ENTRY;
    dentry_t *newdirectory = NULL;
    dentry_t *olddirectory = filesystem->data.directory;
    long allocated = filesystem->data.allocated;
    DEBUG_PRINT("allocated: %ld\n", allocated);
    if (allocated == 0) {
        unsigned long oldsize = filesystem->data.nfiles;
        unsigned long newsize = oldsize * 2;
        newdirectory = (dentry_t*)malloc(sizeof(dentry_t)*newsize);
        if (newdirectory) {
            DEBUG_PRINT("copying fs to new table\n");
            for (unsigned long k = 0; k < oldsize; k++) {
                newdirectory[k] = olddirectory[k];
            }
            for (unsigned long k = oldsize; k < newsize; k++) {
                newdirectory[k] = (dentry_t){ NULL, NULL };
            }
            filesystem->data.directory = newdirectory;
            filesystem->data.allocated = newsize;
        }
    } else {
        unsigned long oldsize = filesystem->data.allocated;
        unsigned long newsize = oldsize * 2;
        newdirectory = (dentry_t*)realloc(olddirectory, sizeof(dentry_t)*newsize);
        if (newdirectory) {
            memset(&newdirectory[oldsize], 0, (newsize-oldsize)*sizeof(dentry_t));
            filesystem->data.directory = newdirectory;
            filesystem->data.allocated = newsize;
        }
    }
    DEBUG_PRINT("newsize=%ld Done\n",filesystem->data.allocated);
    DEBUG_EXIT;
    return newdirectory;
}

static void push_index(long idx)
{
    if (idx >= 0) {
        long last = filesystem->data.last_dentry_idx;
        directory_set_links(idx, last);
        filesystem->data.last_dentry_idx = idx;
    }
}

static long pop_index()
{
    long last = filesystem->data.last_dentry_idx;
    if (last >= 0) {
        filesystem->data.last_dentry_idx = directory_get_links(last);
    }
    return last;
}

static long alloc_directory_entry()
{
    DEBUG_ENTRY;
    long idx = pop_index();

    if (idx == -1) {
        long nfiles = filesystem->data.nfiles;
        idx = nfiles;
        long allocated = filesystem->data.allocated;
        if ((allocated == 0) || (allocated > 0  && nfiles >= allocated - 1)) {
            DEBUG_PRINT("number of files exceeded the space allocated\n");
            dentry_t *newdirectory = reallocate_directory();
            if (!newdirectory) {
                DEBUG_PRINT("failed (no memory to reallocate directory)\n");
                __set_errno(ENOSPC);
                DEBUG_EXIT;
                return -1;
            }
        }
        filesystem->data.nfiles++;
    }

    DEBUG_PRINT("returns: %ld / %ld\n", idx, filesystem->data.nfiles);
    DEBUG_EXIT;
    return idx;
}

#define ALLOC_DIRECTORY_ENTRY()\\
    ({\\
        long new_idx = alloc_directory_entry();\\
        if (new_idx == -1) {\\
            int errsv = __get_errno();\\
            DEBUG_PRINT("failed (cannot get a new entry in directory)\n");\\
            DEBUG_EXIT;\\
            __set_errno(errsv);\\
            return -1;\\
        }\\
        new_idx;\\
    })

static void check_remove_directory_entry(long idx)
{
    if (directory_get_links(idx) == 0 && directory_get_pathname(idx) == NULL) {
        inode_t *inode_p = directory_get_inode(idx);
        directory_set_inode(idx, NULL);
        if (inode_p) inode_unlink(inode_p);
        push_index(idx);
    }
}

static void unlink_directory_entry(long idx)
{
    long links = directory_unlink(idx);
    if (!links) check_remove_directory_entry(idx);
}

static long new_directory_entry_common(const char *pathname, inode_t *inode_p)
{
    DEBUG_ENTRY;
    char *filename = (pathname)? strdup(pathname): NULL;
    DEBUG_PRINT("new file to be created '%s'\n", filename);
    long idx = ALLOC_DIRECTORY_ENTRY();
    directory_set_pathname(idx, filename);
    directory_set_inode(idx, inode_p);
    directory_set_links(idx, 0);
    DEBUG_EXIT;
    return idx;
}

static long dup_directory_entry(long old_idx, const char *newname)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("new hard link '%s' to idx=%ld\n", newname, old_idx);
    inode_t *inode_p = inode_dup(directory_get_inode(old_idx));
    if (!inode_p) {
        DEBUG_PRINT("failed (old inode is null)\n");
        DEBUG_EXIT;
        __set_errno(EIO);
        return -1;
    }
    long new_idx = new_directory_entry_common(newname, inode_p);
    DEBUG_PRINT("OK! hardlink created '%s'\n", newname);
    DEBUG_EXIT;
    return new_idx;
}

static long new_directory_entry(const char *pathname, mode_t mode)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: '%s' %#x\n", pathname, mode);
    inode_t *inode_p = new_inode(mode);
    if (!inode_p) {
        DEBUG_PRINT("failed (no space for new inode)\n");
        DEBUG_EXIT;
        __set_errno(ENOSPC);
        return -1;
    }
    long new_idx = new_directory_entry_common(pathname, inode_p);
    DEBUG_PRINT("OK! directory entry created '%s'\n", pathname);
    DEBUG_EXIT;
    return new_idx;
}

#define NEW_DIRECTORY_ENTRY(pathname, mode)\\
    ({\\
        long idx = new_directory_entry(pathname, mode);\\
        if (idx == -1) {\\
            int errsv = __get_errno();\\
            DEBUG_PRINT("[NEW_DIRECTORY_ENTRY] unable to include '%s' with mode %#x in directory\n", pathname, mode);\\
            DEBUG_EXIT;\\
            __set_errno(errsv);\\
            return -1;\\
        }\\
        idx;\\
    })

#define RLIMIT_NOFILE 64*1024
static file_t ** reallocate_description(int fd)
{
    DEBUG_ENTRY;
    ssize_t oldsize = filesystem->fd.size;
    ssize_t newsize = MIN(fd * 2 + 1, RLIMIT_NOFILE);
    if (oldsize == newsize) {
        DEBUG_PRINT("failed fd table relocation (already max size)\n");
        DEBUG_EXIT;
        return NULL;
    }
    file_t **newfd = (file_t**)realloc(filesystem->fd.fd, newsize*sizeof(file_t*));
    if (newfd) {
        DEBUG_PRINT("reallocated fd table (new size:%d)\n", newsize);
        memset(&newfd[oldsize], 0, (newsize-oldsize)*sizeof(file_t*));
        filesystem->fd.size = newsize;
        filesystem->fd.fd = newfd;
    }
    DEBUG_EXIT;
    return newfd;
}

static void description_set_file(int fd, file_t* ofile)
{
    DEBUG_ENTRY;
    if (fd < 0 || fd >= RLIMIT_NOFILE) {
        DEBUG_PRINT("failed (fd:%d out of range)\n", fd);
        DEBUG_EXIT;
        return;
    }
    filesystem->fd.fd[fd] = ofile;
    DEBUG_EXIT;
}

static file_t* description_get_file(int fd)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d\n", fd);
    if (fd < 0 || fd >= filesystem->fd.size || (filesystem->fd.fd == NULL)) {
        DEBUG_PRINT("failed (fd:%d out of range)\n", fd);
        DEBUG_EXIT;
        __set_errno(EBADF);
        return NULL;
    }

    file_t* ret = filesystem->fd.fd[fd];
    DEBUG_PRINT("returns: %p\n", ret);
    DEBUG_EXIT;
    return ret;
}

#define DESCRIPTION_GET_FILE(fd)\\
    ({\\
        file_t *file = description_get_file(fd);\\
        if (!file) {\\
            DEBUG_PRINT("[DESCRIPTION_GET_FILE] failed (entry %d in description is null, not open)\n", fd);\\
            DEBUG_EXIT;\\
            __set_errno(EBADF);\\
            return -1;\\
        }\\
        file;\\
    })

static int description_is_open(int fd)
{
    return (description_get_file(fd) != NULL);
}

static int description_set_entry_common(int fd, file_t *new_entry)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d file=%p\n", fd, new_entry);
    if (fd < 0 || fd >= RLIMIT_NOFILE) {
        DEBUG_PRINT("failed (fd:%d out of range)\n", fd);
        DEBUG_EXIT;
        __set_errno(EBADF);
        return -1;
    }
    if (!new_entry) {
        DEBUG_PRINT("(failed) entry provided is nul, fd=%d unchanged\n", fd);
        DEBUG_EXIT;
        return -1;
    }
    if ((unsigned long)fd >= filesystem->fd.size) {
        DEBUG_PRINT("reallocating fd table\n");
        reallocate_description(FIRST_FILENO + fd);
        if ((unsigned long)fd >= filesystem->fd.size) {
            DEBUG_PRINT("failed (fd:%d out of range)\n", fd);
            DEBUG_EXIT;
            __set_errno(ENFILE);
            return -1;
        }
    } else if (description_is_open(fd)) close0(fd);
    description_set_file(fd, new_entry);
    openfile_link(new_entry);
    directory_link(openfile_get_directory_entry(new_entry));
    DEBUG_PRINT("DONE.\n");
    DEBUG_EXIT;
    return fd;
}

static void description_set_position(int fd, unsigned long pos)
                {openfile_set_position(filesystem->fd.fd[fd], pos);}
static unsigned long description_get_position(int fd)
                {return openfile_get_position(filesystem->fd.fd[fd]);}
static unsigned int description_get_flags(int fd)
                {return openfile_get_flags(filesystem->fd.fd[fd]);}

#define DESCRIPTION_GET_INODE(fd)\\
    ({\\
        inode_t *inode_p = description_get_inode(fd);\\
        if (inode_p == NULL) {\\
            DEBUG_PRINT("failed (inode is nul)\n");\\
            DEBUG_EXIT;\\
            __set_errno(EIO);\\
            return -1;\\
        }\\
        inode_p;\\
    })

static int description_first_closed()
{
    DEBUG_ENTRY;

    unsigned long fd;
    for (fd = 0; fd < filesystem->fd.size; fd++) {
        if (!description_is_open(fd)) break;
    }
    DEBUG_PRINT("returns: %d\n", fd);
    DEBUG_EXIT;
    return (int)fd;
}

static int description_new_entry(long idx, inode_t *inode_p, int flags)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: idx=%ld, flags=%#x\n", idx, flags);

    file_t *new_entry = new_openfile(idx, inode_p, flags);
    if (!new_entry) {
        int errsv = __get_errno();
        DEBUG_PRINT("failed (no memory for file description)\n");
        DEBUG_EXIT;
        __set_errno(errsv);
        return -1;
    }

    int fd = description_first_closed();
    DEBUG_PRINT("first number available: %d\n", fd);
    fd = description_set_entry_common(fd, new_entry);

    DEBUG_PRINT("fd=%d <- open([%ld] '%s', flags=%#x)\n", fd, idx, directory_get_pathname(idx), flags);
    DEBUG_EXIT;
    return fd;
}

static long description_get_directory_entry(int fd)
{
    DEBUG_ENTRY;
    file_t *ofile = DESCRIPTION_GET_FILE(fd);
    long idx = openfile_get_directory_entry(ofile);
    DEBUG_PRINT("OK! idx=%ld <- fd=%d\n", idx, fd);
    DEBUG_EXIT;
    return idx;
}

#define DESCRIPTION_GET_DIRECTORY_ENTRY(fd)\\
    ({\\
        long idx = description_get_directory_entry(fd);\\
        if (idx == -1) {\\
            DEBUG_EXIT;\\
            __set_errno(ENOENT);\\
            return -1;\\
        }\\
        idx;\\
    })

#define LOC2INDEX_OFFSET 2
static int locreserved(long loc) { return (loc < LOC2INDEX_OFFSET); }
static long loc2index(long loc) { return loc - LOC2INDEX_OFFSET; }
static long index2loc(long idx) { return idx + LOC2INDEX_OFFSET; }

#define ivm64_push_const(c) ({asm volatile("push!  %0":: "i" (c));})
#define ivm64_push_var1(v)  ({asm volatile("load1! %0"::"rm" (v));})
#define ivm64_push_var2(v)  ({asm volatile("load2! %0"::"rm" (v));})
#define ivm64_push_var4(v)  ({asm volatile("load4! %0"::"rm" (v));})
#define ivm64_push_var8(v)  ({asm volatile("load8! %0"::"rm" (v));})
#define ivm64_push_bytes(n,x) do {__builtin_constant_p(x)?ivm64_push_const(x):ivm64_push_var ## n(x);}while(0)

#if (!TERMINAL_COLORS)
    #define CONNECTED_STDOUT_COLOR
    #define CONNECTED_STDERR_COLOR
    #define CLOSED_STDOUT_COLOR
    #define CLOSED_STDERR_COLOR
    #define TERMINAL_RESTORE_COLOR
#else
    #define ANSI_RESTORE    "\x1b[0m"
    #define ANSI_RED_FG     "\x1b[31m"
    #define ANSI_GREEN_FG   "\x1b[32m"
    #define ANSI_YELLOW_FG  "\x1b[33m"
    #define ANSI_BLUE_FG    "\x1b[34m"
    #define ANSI_PURPLE_FG  "\x1b[35m"
    #define ANSI_CYAN_FG    "\x1b[36m"
    #define CONNECTED_STDOUT_COLOR  printk(ANSI_BLUE_FG)
    #define CONNECTED_STDERR_COLOR  printk(ANSI_RED_FG)
    #define CLOSED_STDOUT_COLOR     printk(ANSI_GREEN_FG)
    #define CLOSED_STDERR_COLOR     printk(ANSI_YELLOW_FG)
    #define TERMINAL_RESTORE_COLOR  printk(ANSI_RESTORE)
#endif

#define ivm64_put_lsb_char(c) \\
    do {\\
        ivm64_push_bytes(1, c);\\
        asm volatile("put_char");\\
    } while(0)

#define ivm64_put_wide_char(c) \\
    do {\\
        ivm64_push_bytes(4, c);\\
        asm volatile("put_char");\\
    } while(0)

#define ivm64_put_byte(c) \\
    do {\\
        ivm64_push_bytes(1, c);\\
        asm volatile("put_byte");\\
    } while(0)

static ssize_t write_bytes(const void *vptr, size_t nbytes)
{
    for (char *ptr = (char*)vptr; ptr < (char*)vptr + nbytes; ptr++) {
        ivm64_put_byte(*ptr);
    }
    return nbytes;
}

static void put_utf8char(uint8_t c) {
/*
From https:/ /es.wikipedia.org/wiki/UTF-8
UNICODE        Binary scalar value output  UTF-8 input
000000-00007F  00000000 00000000 0xxxxxxx  0xxxxxxx                             US-ASCII (7 bits)
000080-0007FF  00000000 00000yyy yyxxxxxx  110yyyyy 10xxxxxx                    Symbols of two bytes (first starting with 110, second with 10)
000800-00FFFF  00000000 zzzzyyyy yyxxxxxx  1110zzzz 10yyyyyy 10xxxxxx           Symbols of 3 bytes (first starting with 1110, next with 10)
010000-10FFFF  000uuuzz zzzzyyyy yyxxxxxx  11110uuu 10zzzzzz 10yyyyyy 10xxxxxx  Symbols of 4 bytes (first starting with 11110, next with 10)
*/

#define OMIT_WRONG_CHARACTER
#define REPLACEMENT_CHAR ((uint32_t) 0xfffd)

    static int rem = 0;
    static uint32_t ret;
    if (rem == 0) {
        if (c < 0x80) {
            ret = c;
        } else if (c < 0xc0) {
            __set_errno(EILSEQ);
            #ifdef OMIT_WRONG_CHARACTER
            return;
            #else
            ret = REPLACEMENT_CHAR;
            #endif
        } else if (c < 0xe0) {
            ret = c & ~0xe0;
            rem = 1;
        } else if (c < 0xf0) {
            ret = c & ~0xf0;
            rem = 2;
        } else if (c < 0xf8) {
            ret = c & ~0xf8;
            rem = 3;
        } else {
            __set_errno(EILSEQ);
            #ifdef OMIT_WRONG_CHARACTER
            return;
            #else
            ret = REPLACEMENT_CHAR;
            #endif
        }
    } else {
        if ((c & 0xc0) == 0x80) {
            ret <<= 6;
            ret |= c & 0x3f;
            rem--;
        } else {
            rem = 0;
            __set_errno(EILSEQ);
            #ifdef OMIT_WRONG_CHARACTER
            return;
            #else
            ret = REPLACEMENT_CHAR;
            #endif
        }
    }
    if (!rem) ivm64_put_wide_char(ret);
    return;
}

static ssize_t write_standard(const void *buf, size_t count)
{
    for (char *ptr = (char*)buf; ptr < (char*)buf + count; ptr++) {
        put_utf8char(*ptr);
    }
    return count;
}

#define WRITE_STDOUT_DEVICE(v,n) ({\\
        CONNECTED_STDOUT_COLOR;\\
        size_t cont = write_standard(v, n);\\
        TERMINAL_RESTORE_COLOR;\\
        cont;\\
    })

#define WRITE_STDERR_DEVICE(v,n) ({\\
        CONNECTED_STDERR_COLOR;\\
        size_t cont = write_standard(v, n);\\
        TERMINAL_RESTORE_COLOR;\\
        cont;\\
    })

#define WRITE_CLOSED_STDOUT(v,n) ({\\
        CLOSED_STDOUT_COLOR;\\
        size_t cont = write_standard(v, n);\\
        TERMINAL_RESTORE_COLOR;\\
        cont;\\
    })

#define WRITE_CLOSED_STDERR(v,n) ({\\
        CLOSED_STDERR_COLOR;\\
        size_t cont = write_standard(v, n);\\
        TERMINAL_RESTORE_COLOR;\\
        cont;\\
    })
#define SYSTEM_EOF 4

static uint32_t ivm64_read_char()
{
    static uint32_t c;
    asm volatile("read_char\n\t"
                 "store4! %0":"=m"(c));
    return c;
}

static uint8_t read_utf8char() {
    static uint32_t c;
    static uint8_t buff[4];
    static int count=0, pos=0;

    if (pos == count) {
        count = 0;
        pos = 0;
        c = ivm64_read_char();

        if (c < 0x80) {
            buff[count++] = (uint8_t) c;
        } else if (c < 0x800) {
            buff[count++] = (uint8_t) (0xc0 |         (c >>  6));
            buff[count++] = (uint8_t) (0x80 | (0x3f &  c));
        } else if (c < 0x10000) {
            buff[count++] = (uint8_t) (0xe0 |         (c >> 12));
            buff[count++] = (uint8_t) (0x80 | (0x3f & (c >>  6)));
            buff[count++] = (uint8_t) (0x80 | (0x3f &  c));
        } else {
            buff[count++] = (uint8_t) (0xf0 | (0x07 & (c >> 18)));
            buff[count++] = (uint8_t) (0x80 | (0x3f & (c >> 12)));
            buff[count++] = (uint8_t) (0x80 | (0x3f & (c >>  6)));
            buff[count++] = (uint8_t) (0x80 | (0x3f &  c));
        }
    }

    return buff[pos++];
}

#define PUTS(str) do {char *s=(str); while(*s){ put_utf8char(*s); s++;} } while(0)

static uint8_t read_char_buffered(long bufflen, int emu_echo, int emu_icanon)
{
    static uint8_t buffer[TTYLINESIZE];
    uint8_t *buf = buffer;
    uint8_t ch;
    long len;
    static long count=0, pos=0;

    if (emu_icanon) {
        len = MAX(1L, MIN(bufflen, TTYLINESIZE));
    } else {
        len = 1;
    }

    if (pos == count) {
        pos = 0;
        count = 0;
        do {
            int special = 0;
            ch = read_utf8char();
            if (ch == SYSTEM_EOF) break;
            if (emu_icanon) {
                if (ch == 8 || ch == 127) {
                    if (count > 0) {
                        if (emu_echo)
                            PUTS("\033[1D \033[1D");

                        while (count > 0 && (0x2 == (buf[count-1] >> 6))) {
                                count--;
                        }
                        if (count > 0) count--;
                    }
                    special = 1;
                }
                else if (ch == 033){
                    buf[count++] = '^';
                    buf[count++] = '[';
                    if (emu_echo) {
                        put_utf8char('^'); put_utf8char('[');
                    }
                    special = 1;
                }
            }

            if (!special) {
                buf[count++] = ch;
                if (emu_echo) {
                    put_utf8char(ch);
                }
            }
        } while ( count < len && ch != '\n');
    }

    if (pos < count) {
        return buf[pos++];
    }

    return ch;
}

static ssize_t read_standard(char *buf, size_t len)
{
    unsigned long i = 0;
    unsigned char ch;
    do {
        #if (!IVM_TERMIOS)
        ch = read_utf8char();
        #else
        unsigned long lflag = filesystem->tty_termios.c_lflag;
        int emu_echo = !!(lflag & ECHO);
        int emu_icanon = !!(lflag & ICANON);
        ch = read_char_buffered(TTYLINESIZE, emu_echo, emu_icanon);
        #endif
        if (ch == SYSTEM_EOF) break;
        buf[i++] = ch;
    } while (i < len && ch != '\n');
    return i;
}
typedef enum { FRAME_NONE = -1, FRAME_SET = 0} frame_status_t;

typedef struct {
    uint16_t x;
    uint16_t y;
} coord_t;

typedef struct {
    coord_t dim;
    uint32_t rate;
} param_t;

typedef struct {
    frame_status_t status;
    param_t param;
    coord_t coord;
} frame_t;

frame_t current_read_frame  = { FRAME_NONE, { { 0, 0, }, 0, }, { 0, 0, }, };
frame_t current_write_frame = { FRAME_NONE, { { 0, 0, }, 0, }, { 0, 0, }, };

static void ivm64_new_frame()
{
    asm volatile("new_frame!!! (load2 %[w]) (load2 %[h]) (load4 %[r])" : :
                [w] "m" (current_write_frame.param.dim.x),
                [h] "m" (current_write_frame.param.dim.y),
                [r] "m" (current_write_frame.param.rate));
}

static void ivm64_read_frame(uint64_t index)
{
    asm volatile("read_frame! (load8 %[n])\n\t"
                "store2!     %[h]\n\t"
                "store2!     %[w]" :
                [h]"=m"(current_read_frame.param.dim.y),
                [w]"=m"(current_read_frame.param.dim.x) : [n]"m"(index));
}

void ivm64_set_pixel(unsigned long x, unsigned long y, unsigned long *rgb)
{
    asm volatile("set_pixel* [(load8 %[x]) (load8 %[y]) (load8 %[r]) (load8 %[g]) (load8 %[b])]"
                : : [x]"m"(x), [y]"m"(y), [r]"m"(rgb[0]), [g]"m"(rgb[1]), [b]"m"(rgb[2]));
}

void ivm64_read_pixel(unsigned long x, unsigned long y, unsigned char *v)
{
    asm volatile("read_pixel!! (load8 %[x]) (load8 %[y])\n\t"
                "store1! %[v]"
               : [v] "=m" (v) : [x] "m" (x), [y] "m" (y) );
}

void ivm64_add_sample(uint16_t *v)
{
    asm volatile("add_sample!! (load8 %[l]) (load8 %[r])"
                :: [l] "m" (v[0]), [r] "m" (v[1]) );
}

static ssize_t write_sample(const void *vbuf, size_t count)
{
    if (current_write_frame.status != FRAME_SET) {
        __set_errno(EINVAL);
        return -1;
    }
    const char *buf = (const char*)vbuf;
    const char *ptr;
    size_t itemsize = sizeof(uint16_t) * 2;
    for (ptr = buf; ptr <= buf + count - itemsize; ptr += itemsize) {
        ivm64_add_sample((uint16_t*)ptr);
    }
    return (ptr - buf);
}

static int set_pixel_coords(frame_t *current_frame, off_t index)
{
    uint16_t *px = &current_frame->coord.x;
    uint16_t *py = &current_frame->coord.y;
    if (index == 0) {
        *px = 0;
        *py = 0;
        return 0;
    }
    uint16_t width  = current_frame->param.dim.x;
    uint16_t height = current_frame->param.dim.y;
    if (width == 0 || index >= width * height) {
        *px = 0;
        *py = 0;
        return -1;
    }
    *py = index / width;
    *px = index - width * *py;
    return 0;
}

static off_t update_pixel_coords(frame_t *current_frame)
{
    if (current_frame->param.dim.x == 0) {
        return -1;
    }
    if (++current_frame->coord.x >= current_frame->param.dim.x) {
        current_frame->coord.x = 0;
        if (++current_frame->coord.y >= current_frame->param.dim.y)
            current_frame->coord.y = 0;
    }
    return current_frame->coord.y * current_frame->param.dim.x + current_frame->coord.x;
}

static ssize_t write_pixel(int fd, const void *buf, size_t count, unsigned long itemsize)
{
    if (current_write_frame.status != FRAME_SET || count < itemsize) {
        __set_errno(EINVAL);
        return -1;
    }
    off_t offset = description_get_position(fd);
    off_t index = offset / itemsize;
    set_pixel_coords(&current_write_frame, index);
    uint8_t bytes_per_color = itemsize / 3;
    uint64_t rgb[3];

#ifdef VECTORIZED_WRITE_PIXEL
    const char *cbuf = (const char *)buf;
    const char *ptr;
    for (ptr = cbuf; ptr <= cbuf + count - itemsize; ptr += itemsize) {
        switch (bytes_per_color) {
        general:
        case 8: rgb[0] = ((uint64_t*)ptr)[0];
                rgb[1] = ((uint64_t*)ptr)[1];
                rgb[2] = ((uint64_t*)ptr)[2];
                break;
        case 4: rgb[0] = ((uint32_t*)ptr)[0];
                rgb[1] = ((uint32_t*)ptr)[1];
                rgb[2] = ((uint32_t*)ptr)[2];
                break;
        case 2: rgb[0] = ((uint16_t*)ptr)[0];
                rgb[1] = ((uint16_t*)ptr)[1];
                rgb[2] = ((uint16_t*)ptr)[2];
                break;
        case 1: rgb[0] = ((uint8_t*)ptr)[0];
                rgb[1] = ((uint8_t*)ptr)[1];
                rgb[2] = ((uint8_t*)ptr)[2];
                break;
        default:goto general;
        }
        ivm64_set_pixel(current_write_frame.coord.x, current_write_frame.coord.y, rgb);
        index = update_pixel_coords(&current_write_frame);
    }
    count = ptr - cbuf;
    description_set_position(fd, offset + count);
    return count;
#else
    switch (bytes_per_color) {
    general:
    case 8: rgb[0] = ((uint64_t*)buf)[0];
            rgb[1] = ((uint64_t*)buf)[1];
            rgb[2] = ((uint64_t*)buf)[2];
            break;
    case 4: rgb[0] = ((uint32_t*)buf)[0];
            rgb[1] = ((uint32_t*)buf)[1];
            rgb[2] = ((uint32_t*)buf)[2];
            break;
    case 2: rgb[0] = ((uint16_t*)buf)[0];
            rgb[1] = ((uint16_t*)buf)[1];
            rgb[2] = ((uint16_t*)buf)[2];
            break;
    case 1: rgb[0] = ((uint8_t*)buf)[0];
            rgb[1] = ((uint8_t*)buf)[1];
            rgb[2] = ((uint8_t*)buf)[2];
            break;
    default:goto general;
    }
    ivm64_set_pixel(current_write_frame.coord.x, current_write_frame.coord.y, rgb);
    index = update_pixel_coords(&current_write_frame);
    offset = index * itemsize;
    description_set_position(fd, offset);
    return itemsize;
#endif
}

static ssize_t read_pixel(int fd, void *buf, size_t count)
{
    if (current_read_frame.status != FRAME_SET) {
        __set_errno(EINVAL);
        return -1;
    }
#ifdef VECTORIZED_READ_PIXEL
    off_t offset = description_get_position(fd);

    set_pixel_coords(&current_read_frame, offset);
    const char *cbuf = (const char *)cbuf;
    const char *ptr;
    for (ptr = cbuf; ptr <= cbuf + count - 1; ptr += 1) {
        ivm64_read_pixel(current_read_frame.coord.x, current_read_frame.coord.y, (unsigned char *)buf);
        offset = update_pixel_coords(&current_read_frame);
    }
    count = ptr - buf;
    description_set_position(fd, offset);
    return count;
#else
    off_t offset = description_get_position(fd);
    set_pixel_coords(&current_read_frame, offset);
    ivm64_read_pixel(current_read_frame.coord.x, current_read_frame.coord.y, (unsigned char *)buf);
    offset = update_pixel_coords(&current_read_frame);
    description_set_position(fd, offset);
    return 1;
#endif
}

static ssize_t write_frame(int fd, const void *buf, size_t count)
{
    if (count != sizeof(param_t)) {
        __set_errno(EINVAL);
        return -1;
    }
    param_t param = *(param_t*)buf;
    current_write_frame.status  = FRAME_SET;
    current_write_frame.param   = param;
    current_write_frame.coord.x = 0;
    current_write_frame.coord.y = 0;
    ivm64_new_frame();
    return count;
}

static ssize_t read_frame(int fd, void *vbuf, size_t count)
{
    long itemsize = sizeof(coord_t);
    if (count < itemsize) {
        __set_errno(EINVAL);
        return -1;
    }
    off_t offset = description_get_position(fd);
    unsigned long index = offset / itemsize;

    const char *buf = (const char *)vbuf;
    const char *ptr;
    for (ptr = buf; ptr <= buf + count - itemsize; ptr += itemsize) {
        ivm64_read_frame(index++);
        ((uint16_t*)ptr)[0] = current_read_frame.param.dim.x;
        ((uint16_t*)ptr)[1] = current_read_frame.param.dim.y;
    }
    count = ptr - buf;
    current_read_frame.status   = FRAME_SET;
    current_read_frame.coord.x  = 0;
    current_read_frame.coord.y  = 0;
    description_set_position(fd, offset + count);
    return count;
}
static char* getdirname(const char *pathname, char *buf, unsigned long bufsiz)
{
    if (!buf && bufsiz)  {
        __set_errno(EINVAL);
        return NULL;
    }
    char tmp[PATH_MAX];
    size_t len = strnlen(pathname, PATH_MAX-1);
    strncpy(tmp, pathname, len);
    tmp[len] = '\0';
    char *retname = dirname(tmp);
    if (buf) {
        size_t len = MIN(strnlen(retname, PATH_MAX), bufsiz - 1);
        strncpy(buf, retname, len);
        buf[len] = '\0';
        return buf;
    } else {
        return strdup(retname);
    }
}

static char* getbasename(char *pathname, char *buf, unsigned long bufsiz)
{
    if (!buf && bufsiz) {
        __set_errno(EINVAL);
        return NULL;
    }
    char tmp[PATH_MAX];
    size_t len = strnlen(pathname, PATH_MAX-1);
    strncpy(tmp, pathname, len);
    tmp[len] = '\0';
    char *retname = basename(tmp);
    if (buf) {
        len = MIN(strnlen(retname, PATH_MAX), bufsiz - 1);
        strncpy(buf, retname, len);
        buf[len] = '\0';
        return buf;
    } else {
        return strdup(retname);
    }
}

static int cmp_dirname(const char *directory, const char *filename)
{
    char buff[PATH_MAX];
    size_t len = strnlen(filename, PATH_MAX-1);
    strncpy(buff, filename, len);
    buff[len] = '\0';
    char *fileDirectory = dirname(buff);
    return strncmp(directory, fileDirectory, PATH_MAX);
}

static int cmp_basename(const char *pathname, char *shortname)
{
    char buff[PATH_MAX];
    size_t len = strnlen(pathname, PATH_MAX - 1);
    strncpy(buff, pathname, len);
    buff[len]='\0';
    char *name = basename(buff);
    return strncmp(name, shortname, len);
}
static int resolve_path(char *path, char *result, char *pos)
{
    int cont = 0;
    if (*path == '(') {
        return -1;
    }
    if (*path == '/') {
        *result = '/';
        pos = result + 1;
        path++;
    }
    *pos = 0;
    if (!*path) return 0;
    while (1) {
        char *slash;
        struct stat st;
        slash = *path ? strchr(path, '/') : NULL;
        if (slash) *slash = 0;
        if (!path[0] || (path[0] == '.' &&
           (!path[1] || (path[1] == '.' && !path[2])))) {
            pos--;
            if (pos != result && path[0] && path[1])
                while (*--pos != '/');
        }
        else {
            strcpy(pos, path);
            if (lstat(result, &st) < 0) return -1;
            if (S_ISLNK(st.st_mode)) {
                if (++cont >= MAX_LOOP) {
                    __set_errno(ELOOP);
                    return -1;
                }
                char buf[PATH_MAX];
                int len = readlinkat0(AT_FDCWD, result, buf, PATH_MAX - 1);
                if (len < 0) return -1;
                buf[len] = '\0';
                *pos = 0;
                if (slash) {
                    *slash = '/';
                    strcat(buf, slash);
                }
                strcpy(path, buf);
                if (*path == '/') result[1] = 0;
                pos = strchr(result, 0);
                continue;
            }
            pos = strchr(result, 0);
        }
        if (slash) {
            *pos++ = '/';
            path = slash + 1;
        }
        *pos = 0;
        if (!slash) break;
    }
    return 0;
}

static char* getrealcwd(char *buf, size_t size);
char *realpath0(const char *path, char *resolved_path)
{
    char cwd[PATH_MAX];
    char path_copy[PATH_MAX];
    int res;
    int aloc = 0;
    if (!resolved_path) {
        resolved_path = (char *)malloc(PATH_MAX);
        if (!resolved_path) return NULL;
        aloc = 1;
    }
    if (!*path) {
        __set_errno(ENOENT);
        return NULL;
    }
    if (!getrealcwd(cwd,sizeof(cwd))) goto ret_failed;
    strcpy(resolved_path, "/");
    if (resolve_path(cwd, resolved_path, resolved_path)) goto ret_failed;
    if (strcmp(resolved_path, "/") != 0) strcat(resolved_path, "/");
    strcpy(path_copy, path);
    res = resolve_path(path_copy, resolved_path, strchr(resolved_path, 0));
    if (res) goto ret_failed;
    if (!*resolved_path) strcat(resolved_path, "/");
    return resolved_path;
ret_failed:
    if (aloc) free(resolved_path);
    return NULL;
}

static char* checkpath(const char *name, char *canon_name)
{
    DEBUG_ENTRY;
    char *p;
    const char *base_name;
    char pathname[PATH_MAX];
    struct stat st;

    getdirname(name, pathname, PATH_MAX);
    p=strrchr(name, '/');
    if (p) {
        base_name = p+1;
    } else {
        base_name = name;
    }
    DEBUG_PRINT("pathname='%s' basename='%s'\n",pathname,base_name);
    if (!realpath(pathname, canon_name)) {
        DEBUG_PRINT("realpath -> pathname='%s' (failed), basename='%s' errno=%d\n",canon_name, base_name, __get_errno());
        __set_errno(ENOENT);
        DEBUG_EXIT;
        return NULL;
    }
    if (lstat(canon_name, &st) < 0) {
        __set_errno(ENOENT);
        DEBUG_PRINT("cannot 'lstat' proposed pathname '%s'\n",canon_name);
        DEBUG_EXIT;
        return NULL;
    }
    if (! S_ISDIR(st.st_mode)) {
        DEBUG_PRINT("proposed pathname '%s' is not a valid directory",canon_name);
        DEBUG_EXIT;
        __set_errno(ENOTDIR);
        return NULL;
    }
    DEBUG_PRINT("pathname='%s' (passed), basename='%s' (new)\n",canon_name, base_name);
    if (canon_name[1]) strcat(canon_name, "/");
    strcat(canon_name, base_name);
    DEBUG_PRINT("fullname='%s'\n",canon_name);
    DEBUG_EXIT;
    return canon_name;
}

static int resolve_logicalpath(char *path, char *result, char *pos)
{
    if (*path == '/') {
        *result = '/';
        pos = result+1;
        path++;
    }
    *pos = 0;
    if (!*path) return 0;
    while (1) {
        char *slash;
        slash = *path ? strchr(path,'/') : NULL;
        if (slash) *slash = 0;
        if (!path[0] || (path[0] == '.' &&
           (!path[1] || (path[1] == '.' && !path[2])))) {
            pos--;
            if (pos != result && path[0] && path[1])
            while (*--pos != '/');
        }
        else {
            strcpy(pos,path);
            pos = strchr(result,0);
        }
        if (slash) {
            *pos++ = '/';
            path = slash+1;
        }
        *pos = 0;
        if (!slash) break;
    }
    return 0;
}

static char* logicalpath(const char *__restrict path, char *__restrict resolved_path)
{
    char cwd[PATH_MAX];
    char path_copy[PATH_MAX];
    int res;
    if (!*path) {
        __set_errno(ENOENT); /* SUSv2 */
        return NULL;
    }
    if (!getcwd0(cwd,sizeof(cwd))) return NULL;
    strcpy(resolved_path, "/");
    if (resolve_logicalpath(cwd, resolved_path, resolved_path)) return NULL;
    if (strcmp(resolved_path, "/") != 0) strcat(resolved_path, "/");
    strcpy(path_copy, path);
    res = resolve_logicalpath(path_copy, resolved_path, strchr(resolved_path, 0));
    if (res) return NULL;
    if (!*resolved_path) strcat(resolved_path, "/");
    return resolved_path;
}

static long directory_find_path(const char* path)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: path='%s'\n", path);
    if (path[0] != '/') {
        DEBUG_PRINT("'%s' is not an absolute path\n", path);
        DEBUG_EXIT;
        __set_errno(ENOENT);
        return -1;
    }
    long idx = directory_find_entry(path);
    if (idx == -1) {
        if (__get_errno() != 0) {
            DEBUG_PRINT("failed (not found)\n");
            DEBUG_EXIT;
            __set_errno(ENOENT);
            return -1;
        }
        DEBUG_PRINT("Found as prefix, trying to create proper directory\n");
        mode_t mode = 0777;
        int fd = openat0(AT_FDCWD, path, O_RDONLY|O_DIRECTORY|O_CREAT|O_EXCL, mode);
        if (fd == -1) {
            int errsv = __get_errno();
            DEBUG_PRINT("failed (open: trying to fix prefix directory)\n");
            DEBUG_EXIT;
            __set_errno(errsv);
            return -1;
        }
        idx = description_get_directory_entry(fd);
        close0(fd);
    }
    DEBUG_PRINT("OK! idx=%ld '%s'\n", idx, path);
    DEBUG_EXIT;
    return idx;
}

static ssize_t readlink_common(inode_t *inode_p, char *buf, size_t bufsiz);
static long directory_findat(int dirfd, const char* pathname, char *canon_name, int flags)
{
    DEBUG_ENTRY;
    if (!pathname) {
        DEBUG_EXIT;
        __set_errno(EINVAL);
        return -1;
    }
    if (!*pathname && !(flags & AT_EMPTY_PATH)) {
        DEBUG_PRINT("failed (path is a null string and flag AT_EMPTY_PATH not set)\n");
        DEBUG_EXIT;
        __set_errno(ENOENT);
        return -1;
    }
    char path[PATH_MAX];
    DEBUG_PRINT("query: '%s' with flags %#x\n", pathname, flags);

    if (!*pathname) {
        path[0] = '/';
        path[1] = '\0';
    } else {
        ssize_t len = strnlen(pathname, PATH_MAX-1);
        char buffpathname[PATH_MAX];
        strncpy(buffpathname, pathname, len);
        buffpathname[len] = '\0';
        if (buffpathname[0] == '/') {
            logicalpath(buffpathname, path);
        } else {
            char tmp[PATH_MAX];
            if (dirfd == AT_FDCWD) {
                getrealcwd(tmp, PATH_MAX);
            } else {
                long tmpidx = DESCRIPTION_GET_DIRECTORY_ENTRY(dirfd);
                strcpy(tmp, directory_get_pathname(tmpidx));
            }
            strcat(tmp, "/");
            ssize_t dirlen = strnlen(tmp, PATH_MAX);
            strncat(tmp, buffpathname, PATH_MAX - dirlen - 1);
            logicalpath(tmp, path);
        }
    }
    DEBUG_PRINT("sanitized path '%s' with flags %#x\n", path, flags);

    long idx = directory_find_path(path);
    DEBUG_PRINT("result of first attempt, idx=%ld (errno=%d)\n", idx, (idx==-1)?errno:0);

    if ((idx == -1) && (flags & AT_SYMLINK_NOFOLLOW)) {
        char buff[PATH_MAX];
        getdirname(path, buff, PATH_MAX);
        if (directory_find_path(buff) >= 0) {
            strcpy(canon_name, path);
            DEBUG_PRINT("'%s' not found, but it is available for a NEW file/dir\n", path);
            DEBUG_EXIT;
            __set_errno(0);
            return -1;
        }
    }

    if (idx >= 0 && !(flags & AT_SYMLINK_NOFOLLOW)) {
        int nloops = 0;
        do {
            inode_t *inode_p = DIRECTORY_GET_INODE(idx);
            if (!S_ISLNK(inode_get_mode(inode_p))) break;
            if (nloops++ >= MAX_LOOP) {
                DEBUG_PRINT("failed (LOOP of abs.path.links in directory)\n");
                DEBUG_EXIT;
                __set_errno(ELOOP);
                return -1;
            }
            if (inode_get_data(inode_p)[0] != '/') {
                idx = -1;
                break;
            }
            ssize_t len = readlink_common(inode_p, path, PATH_MAX - 1);
            path[len] = '\0';
            DEBUG_PRINT_VERBOSE("hop! '%s'\n", path);
            idx = directory_find_path(path);
        } while (idx >= 0);
    }
    if (idx >= 0) {
        strcpy(canon_name, path);
        DEBUG_PRINT("'%s' found in directory (idx = %ld)\n", canon_name, idx);
        DEBUG_EXIT;
        return idx;
    }

    char* (*path_foo)(const char *, char *);
    if (flags & AT_SYMLINK_NOFOLLOW) path_foo = checkpath;
    else path_foo = realpath0;
    if (!path_foo(path, canon_name)) {
        int errsv = __get_errno();
        DEBUG_PRINT("failed (not found)\n");
        DEBUG_EXIT;
        if (errsv == ELOOP) __set_errno(ELOOP);
        else __set_errno(ENOENT);
        return -1;
    }
    DEBUG_PRINT("resolved '%s' -> '%s'\n", path, canon_name);
    idx = directory_find_entry(canon_name);
    DEBUG_PRINT("idx=%ld <- query:'%s' -> '%s' (errno=%d)\n", idx, path, canon_name, errno);
    DEBUG_EXIT;
    __set_errno(0);
    return idx;
}

#define DIRECTORY_FINDAT(dirfd, pathname, canonname, flags)\\
    ({\\
        long idx = directory_findat(dirfd, pathname, canonname, flags);\\
        if (idx == -1) {\\
            int errsv = __get_errno();\\
            DEBUG_PRINT("failed ('%s' not found)\n", pathname);\\
            DEBUG_EXIT;\\
            if (errsv == ELOOP) __set_errno(ELOOP);\\
            else __set_errno(ENOENT);\\
            return -1;\\
        }\\
        DEBUG_PRINT("'%s' found in entry %ld as '%s'\n", pathname, idx, canonname);\\
        idx;\\
    })

#define DIRECTORY_CHECK_AVAILABLE(dirfd, pathname, canonname, flags)\\
    do {\\
        if (directory_findat(dirfd, pathname, canonname, flags) >= 0) {\\
            DEBUG_PRINT("failed ('%s' exist as '%s')\n", pathname, canonname);\\
            DEBUG_EXIT;\\
            __set_errno(EEXIST);\\
            return -1;\\
        } else if (__get_errno() != 0) {\\
            int errsv = __get_errno();\\
            DEBUG_PRINT("failed (invalid path: '%s')\n", pathname);\\
            DEBUG_EXIT;\\
            __set_errno(errsv);\\
            return -1;\\
        }\\
        DEBUG_PRINT("'%s' not exist but '%s' is valid\n", pathname, canonname);\\
    }while(0)

static int truncate_common(inode_t *inode_p, off_t length)
{
    DEBUG_ENTRY;
    mode_t mode = inode_get_mode(inode_p);
    if (! (mode & S_IWUSR)) {
        DEBUG_PRINT("failed (the file must be writable)\n");
        __set_errno(EACCES);
        DEBUG_EXIT;
        return -1;
    }
    long allocated = inode_get_allocated(inode_p);
    long size = inode_get_size(inode_p);
    char *data = inode_get_data(inode_p);
    if (length > allocated) {
        char *p;
        allocated = BLKSIZE *((length*2)/BLKSIZE + 1 + EXTRABLKS);
        if (inode_p->dataFixed) {
            p = (char *)malloc(allocated * sizeof(char));
            if (!p) {
                DEBUG_PRINT("failed (not enough space allocating %ld bytes)\n", allocated);
                __set_errno(ENOSPC);
                DEBUG_EXIT;
                return -1;
            }
            if (size > 0) {
                memcpy(p, data, size);
            }
            DEBUG_PRINT("allocated %ld bytes\n", allocated);
        } else {
            p = data;
            p = (char *)realloc(data, allocated * sizeof(char));
            if (!p){
                DEBUG_PRINT("failed (not enough space re-allocating %ld bytes)\n", allocated);
                __set_errno(ENOSPC);
                DEBUG_EXIT;
                return  -1;
            }
            DEBUG_PRINT("re-allocated %ld bytes\n", allocated);
        }
        memset(p + size, 0, length-size);
        inode_set_allocated(inode_p, allocated);
        inode_p->dataFixed = 0;
        inode_set_data(inode_p, p);
    } else if (length > size) {
        memset(data + size, 0, length-size);
    } else {
    }
    inode_set_size(inode_p, length);
    DEBUG_EXIT;
    return 0;
}

int truncate0(const char *pathname, off_t length)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: pathname='%s' length=%ld\n", pathname, length);
    char buff[PATH_MAX];
    long idx = DIRECTORY_FINDAT(AT_FDCWD, pathname, buff, 0);
    inode_t *inode_p = DIRECTORY_GET_INODE(idx);
    int ret = truncate_common(inode_p, length);
    DEBUG_PRINT("returns: %d\n", ret);
    DEBUG_EXIT;
    return ret;
}

static int ftruncate0(int fd, off_t length)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d length=%ld\n", fd, length);
    if ((description_get_flags(fd) & O_ACCMODE) == O_RDONLY) {
        DEBUG_PRINT("fd=%d is not open for writing\n",fd);
        __set_errno(EINVAL);
        DEBUG_EXIT;
        return -1;
    }
    file_t *file = DESCRIPTION_GET_FILE(fd);
    inode_t *inode_p = OPENFILE_GET_INODE(file);
    int ret = truncate_common(inode_p, length);
    DEBUG_PRINT("returns: %d\n", ret);
    DEBUG_EXIT;
    return ret;
}
static ssize_t readlink_common(inode_t *inode_p, char *buf, size_t bufsiz)
{
    mode_t mode = inode_get_mode(inode_p);
    if (!S_ISLNK(mode)) {
        __set_errno(EINVAL);
        DEBUG_PRINT("failed (not a symbolic link)\n");
        DEBUG_EXIT;
        return -1;
    }
    char *data = inode_get_data(inode_p);

    ssize_t len = strnlen(data, bufsiz - 1);
    strncpy(buf, data, len + 1);
    DEBUG_EXIT;
    return len;
}

static ssize_t readlinkat0(int dirfd, const char *pathname, char *buf, size_t bufsiz)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("dirfd=%d\tfilename='%s' (%d is AT_FDCWD)\n", dirfd, pathname, AT_FDCWD);

    char canon_name[PATH_MAX];
    long idx = DIRECTORY_FINDAT(dirfd, pathname, canon_name, AT_SYMLINK_NOFOLLOW);
    inode_t *inode_p = DIRECTORY_GET_INODE(idx);
    ssize_t len = readlink_common(inode_p, buf, bufsiz);
    DEBUG_PRINT("%s -> %s\n", canon_name, buf);
    DEBUG_EXIT;
    return len;
}
static int openat0(int dirfd, const char *pathname, int flags, ...)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("(dirfd=%d, name='%s', flags=%#x,...)\n", dirfd, pathname, flags);
    int isCREAT = flags & O_CREAT;
    int isEXCL = flags & O_EXCL;
    int isTMP = flags & O_TMPFILE;
    char canon_name[PATH_MAX];

    int searchflag = 0;
    if (isTMP) searchflag |= AT_EMPTY_PATH;
    if ((flags & O_NOFOLLOW) || isCREAT) searchflag |= AT_SYMLINK_NOFOLLOW;
    long idx = directory_findat(dirfd, pathname, canon_name, searchflag);

    int canon_name_ok = (__get_errno() == 0);
    int errsv = __get_errno();
    DEBUG_COND_PRINT((idx == -1 && canon_name_ok),
            "-> (fullpath='%s' not found, but it is valid for NEW file/dir)\n", canon_name);

    int shouldCREAT = 0;
    if (idx == -1) {
        if (!isCREAT) {
            DEBUG_PRINT("failed (O_CREAT is not set and '%s' does not exist)\n", pathname);
            DEBUG_EXIT;
            if (errsv == ELOOP) __set_errno(ELOOP);
            else __set_errno(ENOENT);
            return -1;
        }
        if (!canon_name_ok) {
            DEBUG_PRINT("failed (A directory component in '%s' does not exist or is a dangling symbolic link)\n", pathname);
            DEBUG_EXIT;
            __set_errno(errsv);
            return -1;
        }
        shouldCREAT = 1;
    } else if (isTMP) {
        inode_t *ino = DIRECTORY_GET_INODE(idx);
        if (!S_ISDIR(ino->mode)) {
            DEBUG_PRINT("failed ('%s' is not a directory for TMPFILE)\n", canon_name);
            DEBUG_EXIT;
            __set_errno(ENOTDIR);
            return -1;
        }
        shouldCREAT = 1;
    } else if (isCREAT && isEXCL) {
        DEBUG_PRINT("failed ('%s' already exists and O_CREAT and O_EXCL were used)\n", canon_name);
        DEBUG_EXIT;
        __set_errno(EEXIST);
        return -1;
    }
    if (shouldCREAT) {
        va_list arg;
        va_start(arg, flags);
        long mode = va_arg(arg, long);
        va_end(arg);
        mode &= ~filesystem->umask;
        mode |= S_IFREG;
        if (flags & O_DIRECTORY) {
            mode = S_IFDIR | 0777;
        }
        idx = NEW_DIRECTORY_ENTRY((!isTMP)? canon_name: NULL, mode);
        DEBUG_PRINT("NEW [%ld] entry in directory (name='%s', mode=%#o)\n", idx, isTMP? UNNAMED_NAME: canon_name, mode);
    }

    int accflags = (flags & O_ACCMODE);
    if (accflags == 3) {
        DEBUG_PRINT("failed (only one flags of: O_RDWR, O_WRONLY)\n");
        DEBUG_EXIT;
        __set_errno(EINVAL);
        return -1;
    }
    int o_read  = (accflags == O_RDONLY) || (accflags == O_RDWR);
    int o_write = (accflags == O_WRONLY) || (accflags == O_RDWR);

    if (!isTMP && isCREAT && !(flags & O_NOFOLLOW)) {
        idx = DIRECTORY_FINDAT(dirfd, canon_name, canon_name, 0);
    }

    inode_t *inode_p = DIRECTORY_GET_INODE(idx);
    mode_t mode = inode_get_mode(inode_p);
    int m_read  = mode & S_IRUSR;
    int m_write = mode & S_IWUSR;
    if (S_ISLNK(mode)) {
        if (flags & O_PATH) {
            DEBUG_PRINT("O_PATH flag requires no permissions on the object itself\n");
            o_read = 0;
            o_write = 0;
        } else {
            DEBUG_PRINT("failed ('%s' is a symbolic link, and flags specified O_NOFOLLOW but not O_PATH %#x)\n", canon_name, flags);
            DEBUG_EXIT;
            __set_errno(ELOOP);
            return -1;
        }
    } else if (S_ISDIR(mode)) {
        if (o_write || !(flags & O_DIRECTORY)) {
            DEBUG_PRINT("failed ('%s' is a directory without flag O_DIRECTORY %#x)\n", canon_name, flags);
            DEBUG_EXIT;
            __set_errno(EISDIR);
            return -1;
        }
    } else {
        if (flags & O_DIRECTORY) {
            DEBUG_PRINT("failed ('%s' is not a directory with flag O_DIRECTORY %#x)\n", canon_name, flags);
            DEBUG_EXIT;
            __set_errno(ENOTDIR);
            return -1;
        }
    }
    if ((!m_write && o_write) || (!m_read && o_read)) {
        DEBUG_PRINT("failed (permission denied: access mode)\n");
        DEBUG_EXIT;
        __set_errno(EACCES);
        return -1;
    }
    int fd = description_new_entry(idx, inode_p, flags);
    if (fd < 0) {
        int errsv = __get_errno();
        DEBUG_PRINT("failed (cannot open '%s')\n", directory_get_pathname(idx));
        DEBUG_EXIT;
        __set_errno(errsv);
        return -1;
    }
    if (flags & O_TRUNC) {
        inode_set_size(inode_p, 0);
        ssize_t allocated = inode_get_allocated(inode_p);
        if (allocated) {
            memset(inode_get_data(inode_p), 0, allocated);
        }
    }

    DEBUG_PRINT("OK! [idx=%ld] fd=%d <- open(name='%s', flags=0x%x)\n", idx, fd, isTMP? UNNAMED_NAME: canon_name, flags);
    DEBUG_EXIT;
    return fd;
}
static ssize_t read0(int fd, void *vbuf, size_t count)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d count=%ld\n", fd, count);

    char *buf = (char*)vbuf;
    file_t *file = DESCRIPTION_GET_FILE(fd);
    int flags = openfile_get_flags(file);
    if (((flags & O_ACCMODE) == O_WRONLY) || (flags & O_PATH)) {
        DEBUG_PRINT("fd=%d not open for reading (O_WRONLY or O_PATH)\n",fd);
        DEBUG_EXIT;
        __set_errno(EBADF);
        return -1;
    }
    if (!count) {
        DEBUG_PRINT("ok! count=0\n");
        DEBUG_EXIT;
        return 0;
    }

    inode_t *inode_p = OPENFILE_GET_INODE(file);
    char *data = inode_get_data(inode_p);
    mode_t mode = inode_get_mode(inode_p);
    if (S_ISCHR(mode)) {
        if (data) {
            if (strcmp(STDIN_NAME, data) == 0) count = read_standard(buf, count);
            else if (strcmp(ZERO_NAME, data) == 0)  memset(buf, 0, count);
            else if (strcmp(YES_NAME, data) == 0)   memset(buf, 'y', count);
            else if (strcmp(NULL_NAME, data) == 0) count = 0;
            else {
                DEBUG_PRINT("failed (fd='%d' unkown char device: '%s')", fd, data);
                DEBUG_EXIT;
                __set_errno(EPERM);
                return -1;
            }
            DEBUG_PRINT("readed %ld bytes\n", count);
            DEBUG_EXIT;
            return count;
        }
        DEBUG_PRINT("failed (fd='%d' unkown char device)", fd);
        DEBUG_EXIT;
        __set_errno(EPERM);
        return -1;
    } else if (S_ISBLK(mode)) {
        if (data) {
            if (strcmp(FRAMEIN_NAME, data) == 0) count = read_frame(fd, buf, count);
            else if (strcmp(PIXELIN_NAME, data) == 0) count = read_pixel(fd, buf, count);
            else {
                DEBUG_PRINT("failed (fd='%d' unkown block device: '%s')", fd, data);
                DEBUG_EXIT;
                __set_errno(EPERM);
                return -1;
            }
            DEBUG_PRINT("readed %ld bytes\n", count);
            DEBUG_EXIT;
            return count;
        }
        DEBUG_PRINT("failed (fd='%d' unkown block device)", fd);
        DEBUG_EXIT;
        __set_errno(EPERM);
        return -1;
    } else if (S_ISDIR(mode)) {
        DEBUG_EXIT;
        __set_errno(EISDIR);
        return -1;
    }
    long pos = description_get_position(fd);
    DEBUG_PRINT("count=%ld, pos=%ld, size=%ld\n", count, pos, inode_get_size(inode_p));
    long remainder = inode_get_size(inode_p) - pos;
    if (remainder <= 0) {
        DEBUG_PRINT("No more items to read\n");
        DEBUG_EXIT;
        return 0;
    }
    count = MIN(count, remainder);
    if (count > 0) {
        memcpy(buf, data + pos, count);
        description_set_position(fd, pos + count);
    }
    DEBUG_PRINT("OK! count=%ld\n", count);
    DEBUG_EXIT;
    return count;
}

static int close0(int fd)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d\n", fd);
    file_t *file = description_get_file(fd);
    if (!file) {
        DEBUG_PRINT("fd=%d is not valid\n", fd);
        DEBUG_EXIT;
        __set_errno(EBADF);
        return -1;
    }

    inode_t *inode_p = OPENFILE_GET_INODE(file);
    if (S_ISBLK(inode_get_mode(inode_p))) inode_set_size(inode_p, 0);
    long idx = openfile_get_directory_entry(file);
    if (idx >= 0) unlink_directory_entry(idx);
    openfile_unlink(file);
    description_set_file(fd, NULL);
    DEBUG_PRINT("closed fd=%d\n", fd);

    DEBUG_EXIT;
    return 0;
}

static off_t lseek0(int fd, off_t offset, int whence)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d, offset=%ld, whence=%s\n", fd, offset,
                (whence == SEEK_CUR)? "SEEK_CUR":
                (whence == SEEK_END)? "SEEK_END": "SEEK_SET");
    file_t *file = DESCRIPTION_GET_FILE(fd);
    inode_t *inode_p = OPENFILE_GET_INODE(file);
    mode_t mode = inode_get_mode(inode_p);
    if (S_ISCHR(mode)) {
        DEBUG_PRINT("char device: nothing to do\n");
        DEBUG_EXIT;
        __set_errno(ESPIPE);
        return -1;
    }

    switch(whence) {
        case SEEK_CUR:
            offset += description_get_position(fd);
            break;
        case SEEK_END:
            offset += inode_get_size(inode_p);
            break;
        case SEEK_SET:
        default:
            break;
    }

    if (S_ISDIR(mode)) {
        DEBUG_PRINT("directory\n");
        long newidx = loc2index(offset);
        if (!locreserved(offset) &&
            newidx >= 0 && (unsigned long)newidx < filesystem->data.nfiles) {
            long idx = description_get_directory_entry(fd);
            char *refname = directory_get_pathname(idx);
            char *filename = directory_get_pathname(newidx);
            DEBUG_PRINT_VERBOSE("checking if '%s' belongs to '%s'\n", filename, refname);
            if (cmp_dirname(refname, filename) != 0) {
                DEBUG_PRINT("failed (loc not valid)\n");
                DEBUG_EXIT;
                __set_errno(EINVAL);
                return -1;
            }
        }
    } else if (S_ISBLK(mode)) {
        DEBUG_PRINT("block device\n");
        char* data = inode_get_data(inode_p);
        if (data) {
            if (((strcmp(PIXELOUT_NAME,  data) == 0) && (offset % 24)) ||
                ((strcmp(PIXELOUT_NAME4, data) == 0) && (offset % 12)) ||
                ((strcmp(PIXELOUT_NAME2, data) == 0) && (offset %  6)) ||
                ((strcmp(PIXELOUT_NAME1, data) == 0) && (offset %  3))) {
                DEBUG_EXIT;
                __set_errno(EINVAL);
                return -1;
            }
        }
    }

    DEBUG_PRINT("returns: %ld (fd=%d, whence=%s) [size=%ld]\n", offset, fd,
                (whence == SEEK_CUR)? "SEEK_CUR":
                (whence == SEEK_END)? "SEEK_END": "SEEK_SET", inode_get_size(inode_p));
    description_set_position(fd, offset);
    DEBUG_EXIT;
    return offset;
}

static ssize_t write0(int fd, const void *vptr, size_t count)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d, ptr=%p, count=%d\n", fd, vptr, count);
    char *ptr = (char*)vptr;

    file_t *file = description_get_file(fd);
    if (file == NULL) {
        ssize_t cont = -1;
        if (fd == STDOUT_FILENO) cont = WRITE_CLOSED_STDOUT(vptr, count);
        else if (fd == STDERR_FILENO) cont = WRITE_CLOSED_STDERR(vptr, count);
        else
            __set_errno(EBADF);
        DEBUG_EXIT;
        return cont;
    }

    int flags = openfile_get_flags(file);
    if (((flags & O_ACCMODE) == O_RDONLY) || (flags & O_PATH)) {
        DEBUG_PRINT("failed (flags=%#x includes O_RDONLY or O_PATH\n", flags);
        DEBUG_EXIT;
        __set_errno(EBADF);
        return -1;
    }
    inode_t *inode_p = OPENFILE_GET_INODE(file);
    mode_t mode = inode_get_mode(inode_p);
    if (S_ISCHR(mode)) {
        char *data = inode_get_data(inode_p);
        if (data) {
            if (strcmp(NULL_NAME, data) == 0)           {}
            else if (strcmp(STDOUT_NAME, data) == 0)    count = WRITE_STDOUT_DEVICE(vptr, count);
            else if (strcmp(STDERR_NAME, data) == 0)    count = WRITE_STDERR_DEVICE(vptr, count);
            else if (strcmp(BYTES_NAME,  data) == 0)    count = write_bytes(vptr, count);
            else if (strcmp(FRAMEOUT_NAME, data) == 0)  count = write_frame(fd, vptr, count);
            else if (strcmp(SAMPLE_NAME, data) == 0)    count = write_sample(vptr, count);
            else {
                DEBUG_PRINT("failed (fd='%d' unkown char device: '%s')", fd, data);
                DEBUG_EXIT;
                __set_errno(EPERM);
                return -1;
            }
            DEBUG_PRINT("written %ld bytes in fd=%d (char device)\n", count, fd);
            DEBUG_EXIT;
            return count;
        }
        DEBUG_PRINT("failed (fd='%d' unkown char device with null data)", fd);
        DEBUG_EXIT;
        __set_errno(EPERM);
        return -1;
    }
    if (S_ISBLK(mode)) {
        char *data = inode_get_data(inode_p);
        if (data) {
            if (strcmp(PIXELOUT_NAME, data) == 0)
                count = write_pixel(fd, vptr, count, 24);
            else if (strcmp(PIXELOUT_NAME4, data) == 0)
                count = write_pixel(fd, vptr, count, 12);
            else if (strcmp(PIXELOUT_NAME2, data) == 0)
                count = write_pixel(fd, vptr, count, 6);
            else if (strcmp(PIXELOUT_NAME1, data) == 0)
                count = write_pixel(fd, vptr, count, 3);
            else {
                DEBUG_PRINT("failed (fd='%d' unkown block device: '%s')", fd, data);
                DEBUG_EXIT;
                __set_errno(EPERM);
                return -1;
            }
            DEBUG_PRINT("written %ld bytes in fd=%d (block device)\n", count, fd);
            DEBUG_EXIT;
            return count;
        }
        DEBUG_PRINT("failed (fd='%d' unkown block device with null data)", fd);
        DEBUG_EXIT;
        __set_errno(EPERM);
        return -1;
    }
    unsigned long size = inode_get_size(inode_p);
    if (S_ISDIR(mode)) {
        DEBUG_PRINT("failed (fd=%d is a directory)\n", fd);
        DEBUG_EXIT;
        __set_errno(EBADF);
        return -1;
    }
    if (description_get_flags(fd) & O_APPEND) {
        description_set_position(fd, size);
    }
    unsigned long pos = description_get_position(fd);
    unsigned long new_pos = pos + count;
    unsigned long allocated = inode_get_allocated(inode_p);
    DEBUG_PRINT("fd=%d, count=%ld, pos=%ld, size=%ld, allocated=%ld\n",
                    fd, count, pos, size, allocated);
    if (new_pos > allocated) {
        if (truncate_common(inode_p, new_pos) == -1) {
            int errsv = __get_errno();
            DEBUG_PRINT("failed (truncating fd=%d to %lf)\n", fd, new_pos);
            DEBUG_EXIT;
            __set_errno(errsv);
            return -1;
        }
    }
    char *data = inode_get_data(inode_p);
    if (pos > size) {
        memset(data + size, 0, pos - size);
    }
    memcpy(data + pos, ptr, count);
    inode_set_size(inode_p, MAX((unsigned long)inode_get_size(inode_p), new_pos));
    description_set_position(fd, new_pos);
    DEBUG_EXIT;
    return count;
}
static int dup20(int oldfd, int newfd)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: %d -> %d\n", oldfd, newfd);
    file_t *old = DESCRIPTION_GET_FILE(oldfd);
    if (oldfd == newfd) {
        DEBUG_PRINT("returns: %d (same fd)\n", newfd);
        DEBUG_EXIT;
        return newfd;
    }
    file_t *newfile = description_get_file(newfd);
    if (old == newfile) {
        DEBUG_PRINT("returns: %d (same file_t)\n", newfd);
        DEBUG_EXIT;
        return newfd;
    }
    int res = description_set_entry_common(newfd, old);

    DEBUG_PRINT("returns: %d\n", res);
    DEBUG_EXIT;
    return res;
}

static int dup0(int oldfd)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: %d\n", oldfd);

    file_t *old = DESCRIPTION_GET_FILE(oldfd);
    int res = description_first_closed();
    res = description_set_entry_common(res, old);

    DEBUG_PRINT("returns: %d\n", res);
    DEBUG_EXIT;
    return res;
}

static int stat_common(inode_t *inode_p, struct stat *st)
{
    DEBUG_ENTRY;
    st->st_dev = 1;
    st->st_ino = (unsigned long)inode_p;
    st->st_mode = inode_get_mode(inode_p);
    st->st_nlink = inode_get_links(inode_p);
    st->st_uid = 0;
    st->st_gid = 0;
    st->st_rdev = 0;
    st->st_size = inode_get_size(inode_p);
    st->st_blksize = 1;
    st->st_blocks = inode_get_allocated(inode_p);
    st->st_atim = (struct timespec){0, 0};
    st->st_mtim = (struct timespec){0, 0};
    st->st_ctim = (struct timespec){0, 0};
    st->st_spare4[0] = (long)0;
    st->st_spare4[1] = (long)0;
    DEBUG_EXIT;
    return 0;
}

static int fstat0(int fd, struct stat *st)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d\n", fd);
    file_t *file = DESCRIPTION_GET_FILE(fd);
    inode_t *inode_p = OPENFILE_GET_INODE(file);
    int ret = stat_common(inode_p, st);
    DEBUG_PRINT("returns: OK! (ino=%p size=%ld)\n", inode_p, st->st_size);
    DEBUG_EXIT;
    return ret;
}

static int fstatat0(int dirfd, const char *pathname, struct stat *statbuf, int flags)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: dirfd=%d pathname='%s'\n", dirfd, pathname);
    char canon_name[PATH_MAX];
    long idx = DIRECTORY_FINDAT(dirfd, pathname, canon_name, flags);
    inode_t *inode_p = DIRECTORY_GET_INODE(idx);
    int ret = stat_common(inode_p, statbuf);
    DEBUG_PRINT("returns: OK! (ino=%p size=%ld)\n", inode_p, statbuf->st_size);
    DEBUG_EXIT;
    return ret;
}

static int faccessat0(int dirfd, const char *pathname, int mode, int flags)
{
    struct stat s;
    return fstatat0(dirfd, pathname, &s, flags);
}

static int fsync0(int fd)
{
    return 0;
}

static int fdatasync0(int fd)
{
    return 0;
}

static int utime0(const char *filename, const struct utimbuf *times)
{
    return 0;
}

static int utimes0(const char *filename, const struct timeval times[2])
{
    return 0;
}

static int ioctl0(int fd, unsigned long request, va_list arg)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d, request: %ld\n", fd, request);
    int retval = 0;
    struct termios *t;
    file_t *file = DESCRIPTION_GET_FILE(fd);
    inode_t *inode_p = OPENFILE_GET_INODE(file);
    mode_t mode = inode_get_mode(inode_p);
    char*  data = inode_get_data(inode_p);
    if (!S_ISCHR(mode) || !data || (strcmp(data, STDIN_NAME) != 0)) {
        DEBUG_PRINT("failed: descriptor %d is not the statndard input character device\n", fd);
        __set_errno(ENOTTY);
        retval = -1;
    } else {
        switch (request) {
            case TCGETS:
                t = va_arg(arg, struct termios *);
                DEBUG_PRINT("GET current c_lflag=%#x\n", filesystem->tty_termios.c_lflag);
                *t = filesystem->tty_termios;
                break;
            case TCSETS:
            case TCSETSW:
            case TCSETSF:
                t = va_arg(arg, struct termios *);
                DEBUG_PRINT("SET current c_lflag=%#x passed c_lflag=%#x\n", filesystem->tty_termios.c_lflag, t->c_lflag);
                filesystem->tty_termios = *t;
                break;
            default:
                DEBUG_PRINT("failed: unknown request: %ld\n", request);
                __set_errno(EINVAL);
                retval = -1;
                break;
        }
    }
    DEBUG_EXIT;
    return retval;
}

static mode_t umask0(mode_t mask)
{
    mode_t current = filesystem->umask;
    filesystem->umask = mask & 0777;
    return current;
}

static char* getcwd_common(char *buf, size_t size, int real)
{
    DEBUG_ENTRY;
    char *ret = buf;
    if (size == 0 && buf) {
        DEBUG_PRINT("failed (the size argument is zero and buf is not a null pointer)\n");
        DEBUG_EXIT;
        __set_errno(EINVAL);
        return NULL;
    }
    DEBUG_PRINT("CWD stored: '%s' maxsize=%ld\n", filesystem->cwd.soft, size);
    char *cwd = filesystem->cwd.soft;
    if (!cwd || !*cwd || *cwd != '/') {
        free(cwd);
        char *rcwd = filesystem->cwd.real;
        if (!rcwd || !*rcwd || *rcwd != '/' ||
            (directory_find_entry(filesystem->cwd.real) == -1)) {
            free(rcwd);
            filesystem->cwd.real = strdup("/");
        }
        filesystem->cwd.soft = strdup(filesystem->cwd.real);
    }
    char *query = real? filesystem->cwd.real: filesystem->cwd.soft;
    if (ret) {
        size_t len = strnlen(query, PATH_MAX - 1);
        if (len > size - 1) {
            DEBUG_PRINT("The size argument is less than the length of the pathname '%s'\n", query);
            DEBUG_EXIT;
            __set_errno(ERANGE);
            return NULL;
        }
        strncpy(ret, query, len);
        ret[len] = '\0';
    } else {
        ret = strdup(query);
        if (!ret) {
            DEBUG_PRINT("no memory to set cwd to '%s'\n", query);
            DEBUG_EXIT;
            __set_errno(ENOMEM);
            return NULL;
        }
    }
    DEBUG_PRINT("CWD returned: '%s' (%s)\n", buf, real? "real": "soft");
    DEBUG_EXIT;
    return ret;
}

static char* getrealcwd(char *buf, size_t size)
{
    return getcwd_common(buf, size, 1);
}

static char* getcwd0(char *buf, size_t size)
{
    return getcwd_common(buf, size, 0);
}
static int fcntl0(int fd, int cmd, va_list arg )
{
    int flags;
    file_t *file = DESCRIPTION_GET_FILE(fd);
    switch (cmd) {
        case F_DUPFD:
        case F_DUPFD_CLOEXEC:
                    return dup0(fd);
                    break;
        case F_GETFD:
        case F_SETFD:
                    break;
        case F_GETFL:
                    return openfile_get_flags(file);
                    break;
        case F_SETFL:
                    flags = va_arg(arg, int);
                    flags |= O_APPEND;
                    openfile_set_flags(file, openfile_get_flags(file) | flags);
                    break;
        default:    break;
    }
    return 0;
}

static int symlinkat0(const char *target, int newdirfd, const char *linkpath)
{
    DEBUG_ENTRY;
    if (!target || !*target || !linkpath || !*linkpath) {
        DEBUG_PRINT("target or linkpath is an empty string\n");
        DEBUG_EXIT;
        __set_errno(ENOENT);
        return -1;
    }
    char canon_name[PATH_MAX];
    DIRECTORY_CHECK_AVAILABLE(newdirfd, linkpath, canon_name, AT_SYMLINK_NOFOLLOW);
    long idx = NEW_DIRECTORY_ENTRY(canon_name, S_IFLNK | 0777);
    inode_t *inode_p = DIRECTORY_GET_INODE(idx);
    inode_set_data(inode_p, strdup(target));
    inode_set_size(inode_p, strnlen(target, PATH_MAX));

    DEBUG_PRINT("OK! symlink created\n");
    DEBUG_EXIT;
    return 0;
}

static int linkat0(int olddirfd, const char *oldpath,
                  int newdirfd, const char *newpath, int flags)
{
    DEBUG_ENTRY;
    if ((!oldpath || !*oldpath || !newpath || !*newpath) &&
        !(flags & AT_EMPTY_PATH)) {
        DEBUG_PRINT("oldpath or newpath is an empty string and flag AT_EMPTY_PATH is not set\n");
        DEBUG_EXIT;
        __set_errno(ENOENT);
        return -1;
    }
    char newcanonname[PATH_MAX];
    DIRECTORY_CHECK_AVAILABLE(newdirfd, newpath, newcanonname, flags | AT_SYMLINK_NOFOLLOW);
    char oldcanonname[PATH_MAX];
    long idx = DIRECTORY_FINDAT(olddirfd, oldpath, oldcanonname, flags);
    inode_t *inode_p = DIRECTORY_GET_INODE(idx);
    mode_t mode = inode_get_mode(inode_p);

    if (S_ISDIR(mode)) {
        DEBUG_PRINT("oldpath '%s' is a directory\n", oldpath);
        __set_errno(EPERM);
        return -1;
    }
    long new_idx = dup_directory_entry(idx, newcanonname);
    if (new_idx < 0) {
        int errsv = __get_errno();
        DEBUG_EXIT;
        __set_errno(errsv);
        return -1;
    }

    DEBUG_PRINT("OK!\n");
    DEBUG_EXIT;
    return 0;
}
static int unlink_common(long idx, int flags)
{
    DEBUG_ENTRY;
    char *pathname = directory_get_pathname(idx);
    inode_t *inode_p = DIRECTORY_GET_INODE(idx);
    mode_t mode = inode_get_mode(inode_p);
    if (S_ISDIR(mode)) {
        if (!(flags & AT_REMOVEDIR)) {
            DEBUG_PRINT("failed ('%s' refers to a directory, and AT_REMOVEDIR was not specified in flags)\n", pathname);
            DEBUG_EXIT;
            __set_errno(EISDIR);
            return -1;
        }
        if (directory_find_subentry(pathname, 0) >= 0) {
            DEBUG_EXIT;
            __set_errno(ENOTEMPTY);
            return -1;
        }
    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {
        if (inode_get_links(inode_p) < 2 ||
            cmp_basename(directory_get_pathname(idx), inode_get_data(inode_p)) == 0) {
            DEBUG_PRINT("failed (cannon unlink special device)\n");
            DEBUG_EXIT;
            __set_errno(EPERM);
            return -1;
        }
    }
    directory_set_pathname(idx, NULL);
    check_remove_directory_entry(idx);
    DEBUG_PRINT("pathname='%s' DONE\n", pathname);
    DEBUG_EXIT;
    return 0;
}

static int unlinkat0(int dirfd, const char *pathname, int flags)
{
    DEBUG_ENTRY;
    char buff[PATH_MAX];
    long idx = DIRECTORY_FINDAT(dirfd, pathname, buff, flags | AT_SYMLINK_NOFOLLOW);
    int ret = unlink_common(idx, flags);
    DEBUG_EXIT;
    return ret;
}
static int chdir0(const char *path)
{
    DEBUG_ENTRY;
    char soft_name[PATH_MAX];
    DEBUG_PRINT("'%s' -> '%s' ?\n", filesystem->cwd.soft, path);
    if (!logicalpath(path, soft_name)) {
        DEBUG_PRINT("failed (unable to resolve logical path, perhaps invalid cwd)\n");
        DEBUG_EXIT;
        __set_errno(ENOENT);
        return -1;
    }
    DEBUG_PRINT("'%s' -> '%s'\n", path, soft_name);
    if (filesystem->cwd.soft && soft_name && strcmp(filesystem->cwd.soft, soft_name)==0) {
        DEBUG_PRINT("Identical path: nothing to do\n");
        DEBUG_EXIT;
        return 0;
    }

    char canon_name[PATH_MAX];
    long idx = directory_findat(AT_FDCWD, soft_name, canon_name, 0);
    if (idx == -1) {
        if (realpath(filesystem->cwd.soft, canon_name)) {
            DEBUG_PRINT("failed: directory not found\n");
            DEBUG_EXIT;
            __set_errno(ENOENT);
            return -1;
        }
        free(filesystem->cwd.soft);
        filesystem->cwd.soft = strdup(filesystem->cwd.real);
        logicalpath(path, soft_name);
        idx = DIRECTORY_FINDAT(AT_FDCWD, soft_name, canon_name, 0);
    }
    inode_t *inode_p = DIRECTORY_GET_INODE(idx);
    if (!S_ISDIR(inode_get_mode(inode_p))) {
        DEBUG_PRINT("failed ('%s' is not a directory)\n", canon_name);
        DEBUG_EXIT;
        __set_errno(ENOTDIR);
        return -1;
    }
    free(filesystem->cwd.soft);
    filesystem->cwd.soft = strdup(soft_name);
    free(filesystem->cwd.real);
    filesystem->cwd.real = strdup(canon_name);
    DEBUG_PRINT("current directory: '%s' [%s]\n", soft_name, canon_name);
    DEBUG_EXIT;
    return 0;
}

static int fchdir0(int fd)
{
    DEBUG_ENTRY;
    file_t *file = DESCRIPTION_GET_FILE(fd);
    inode_t *inode_p = OPENFILE_GET_INODE(file);
    mode_t mode = inode_get_mode(inode_p);
    if (!S_ISDIR(mode)) {
        DEBUG_EXIT;
        __set_errno(ENOTDIR);
        return -1;
    }
    long idx = DESCRIPTION_GET_DIRECTORY_ENTRY(fd);

    char *newcwd = directory_get_pathname(idx);
    free(filesystem->cwd.soft);
    filesystem->cwd.soft = strdup(newcwd);
    free(filesystem->cwd.real);
    filesystem->cwd.real = strdup(newcwd);
    return 0;
}
int renameat0(int olddirfd, const char *oldpath, int newdirfd, const char *newpath)
{
    DEBUG_ENTRY;
    if (!oldpath || !*oldpath || !newpath || !*newpath) {
        DEBUG_PRINT("failed (oldpath or new path is an empty string)\n");
        DEBUG_EXIT;
        __set_errno(ENOENT);
        return -1;
    }
    struct fileinfo {
        char *path;
        char name[PATH_MAX];
        long idx;
        size_t len;
        inode_t *ino;
        mode_t mode;
    } oldfile, newfile;

    oldfile.idx = DIRECTORY_FINDAT(olddirfd, oldpath, oldfile.name, AT_SYMLINK_NOFOLLOW);
    oldfile.len = strnlen(oldfile.name, PATH_MAX - 1);
    oldfile.ino = DIRECTORY_GET_INODE(oldfile.idx);
    oldfile.mode = inode_get_mode(oldfile.ino);

    newfile.idx = directory_findat(newdirfd, newpath, newfile.name, AT_SYMLINK_NOFOLLOW);
    newfile.ino = NULL;
    newfile.mode = oldfile.mode;
    if (newfile.idx == -1) {
        if (__get_errno() != 0) {
            DEBUG_PRINT("failed (a directory component in newpath does not exist)\n");
            DEBUG_EXIT;
            __set_errno(ENOENT);
            return -1;
        }
        newfile.len = strnlen(newfile.name, PATH_MAX - 1);
    } else {
        newfile.len = strnlen(newfile.name, PATH_MAX - 1);
        if (oldfile.len == newfile.len && strcmp(oldfile.name, newfile.name) == 0) {
            DEBUG_PRINT("'%s' and '%s' refer to the same file '%s'\n", oldpath, newpath, oldfile.name);
            DEBUG_EXIT;
            return 0;
        }
        newfile.ino = DIRECTORY_GET_INODE(newfile.idx);
        if (oldfile.ino == newfile.ino) {
            DEBUG_PRINT("'%s' and '%s' are existing hard links referring to the same file\n", oldpath, newpath);
            DEBUG_PRINT("assert (nlinks:%d > 1)\n", oldfile.ino->links);
            DEBUG_EXIT;
            return 0;
        }
        newfile.mode = inode_get_mode(newfile.ino);
    }
    if (S_ISDIR(oldfile.mode)) {
        if (!S_ISDIR(newfile.mode)) {
            DEBUG_PRINT("failed (newpath is not a directory)");
            DEBUG_EXIT;
            __set_errno(ENOTDIR);
            return -1;
        }
        if (newfile.len > oldfile.len &&
            strncmp(oldfile.name, newfile.name, oldfile.len) == 0 &&
            newfile.name[oldfile.len] == '/') {
            DEBUG_PRINT("failed (cannot move '%s' to a subdirectory of itself)", oldfile.name);
            DEBUG_EXIT;
            __set_errno(EINVAL);
            return -1;
        }
        if (newfile.idx != -1 && (unlink_common(newfile.idx, AT_REMOVEDIR) == -1)) {
            DEBUG_PRINT("failed (newpath is a nonempty directory)");
            DEBUG_EXIT;
            __set_errno(ENOTEMPTY);
            return -1;
        }
        if (oldfile.len >= newfile.len) {
            strncpy(directory_get_pathname(oldfile.idx), newfile.name, newfile.len + 1);
        } else {
           directory_set_pathname(oldfile.idx, strdup(newfile.name));
        }
        long idx = 0;
        for (;;) {
            idx = directory_find_subentry(oldfile.name, idx);
            if (idx == -1) break;
            char *nameintable = directory_get_pathname(idx);
            char *newentry;
            ssize_t bsname_len = strlen(nameintable) - (oldfile.len + 1);
            if (oldfile.len >= newfile.len) {
                newentry = nameintable;
            } else {
                newentry = (char*)malloc(newfile.len + 1 + bsname_len + 1);
                directory_set_pathname(idx, newentry);
            }
            strncpy(newentry, newfile.name, newfile.len);
            newentry[newfile.len] = '/';
            strncpy(newentry + (newfile.len + 1),
                    nameintable + (oldfile.len + 1), bsname_len);
            newentry[newfile.len + 1 + bsname_len] = '\0';
            idx++;
        }
        DEBUG_EXIT;
        return 0;
    }
    if (S_ISDIR(newfile.mode)) {
        DEBUG_PRINT("failed (newpath is a directory)");
        DEBUG_EXIT;
        __set_errno(EISDIR);
        return -1;
    }
    if (newfile.idx != -1 && (unlink_common(newfile.idx, 0) == -1)) {
        DEBUG_PRINT("failed (write permission denied: '%s')\n", newfile.name);
        DEBUG_EXIT;
        __set_errno(EACCES);
        return -1;
    }
    if (S_ISCHR(oldfile.mode) || S_ISBLK(oldfile.mode)) {
        if (inode_get_links(oldfile.ino) < 2 ||
            cmp_basename(directory_get_pathname(oldfile.idx), inode_get_data(oldfile.ino)) == 0) {
            DEBUG_PRINT("failed (cannon rename special device)\n");
            DEBUG_EXIT;
            __set_errno(EPERM);
            return -1;
        }
    }
    if (oldfile.len >= newfile.len) {
        char *nameintable = directory_get_pathname(oldfile.idx);
        strncpy(nameintable, newfile.name, newfile.len);
        nameintable[newfile.len] = '\0';
    } else {
       directory_set_pathname(oldfile.idx, strdup(newfile.name));
    }
    DEBUG_PRINT("OK! '%s' renamed to '%s'\n", oldfile.name, newfile.name);
    DEBUG_EXIT;
    return 0;
}
long directory_search(const char *refname, long idx)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: '%s' from %ld\n", refname, idx);
    if (idx < 0 || (unsigned long)idx >= filesystem->data.nfiles) {
        DEBUG_PRINT("failed (%ld >= %ld [nfiles])\n", idx, filesystem->data.nfiles);
        DEBUG_EXIT;
        return -1;
    }
    char *filename = NULL;
    for (;;) {
        idx = directory_find_subentry(refname, idx);
        if (idx == -1) break;
        filename = directory_get_pathname(idx);
        DEBUG_PRINT_VERBOSE("is '%s' into '%s' ?\n", filename, refname);
        if (filename && filename[1] != '\0' && cmp_dirname(refname, filename) == 0) break;
        DEBUG_PRINT_VERBOSE("NO!\n");
        idx++;
    }
    DEBUG_PRINT("returns: %ld -> '%s'\n", idx, filename);
    DEBUG_EXIT;
    return idx;
}

static long getdents0(int fd, struct dirent *dirp, size_t count)
{
    DEBUG_ENTRY;
    size_t direntsize = sizeof(struct dirent);
    if (count < direntsize) {
        DEBUG_EXIT;
        __set_errno(EINVAL);
        return -1;
    }
    file_t *file = DESCRIPTION_GET_FILE(fd);
    inode_t *inode_p = OPENFILE_GET_INODE(file);
    mode_t mode = inode_get_mode(inode_p);
    if (!S_ISDIR(mode)) {
        DEBUG_EXIT;
        __set_errno(ENOENT);
        return -1;
    }
    long loc = description_get_position(fd);
    if (loc == -1) {
        DEBUG_EXIT;
        return 0;
    }

    int nelem = count / direntsize;
    long idx = DESCRIPTION_GET_DIRECTORY_ENTRY(fd);
    DEBUG_PRINT("query: fd=%d, idx=%ld (nelem=%d)\n", fd, idx, nelem);
    char *refname = directory_get_pathname(idx);

    int i = 0;
    if (loc == 0) {
        dirp[0].d_ino = (unsigned long)inode_p;
        dirp[0].d_off = 0;
        dirp[0].d_reclen = direntsize;
        dirp[0].d_type = DT_DIR;
        dirp[0].d_name[0] = '.';
        dirp[0].d_name[1] = '\0';
        loc = 1;
        i++;
    }
    if (i < nelem && loc == 1) {
        char buff[PATH_MAX];
        getdirname(refname, buff, PATH_MAX);
        idx = directory_find_entry(buff);
        inode_p = directory_get_inode(idx);
        dirp[i].d_ino = (unsigned long)inode_p;
        dirp[0].d_off = 1;
        dirp[i].d_reclen = direntsize;
        dirp[i].d_type = DT_DIR;
        dirp[i].d_name[0] = '.';
        dirp[i].d_name[1] = '.';
        dirp[i].d_name[2] = '\0';
        loc = 2;
        i++;
    }
    idx = loc2index(loc);
    for (; i < nelem; i++) {
        DEBUG_PRINT("retrieving info from dir: '%s', from index=%ld (elem=%ld)\n", refname, idx, i);
        idx = directory_search(refname, idx);
        if (idx == -1) break;

        inode_p = DIRECTORY_GET_INODE(idx);
        dirp[i].d_ino = (unsigned long)inode_p;

        dirp[i].d_off = index2loc(idx);

        dirp[i].d_reclen = direntsize;
        dirp[i].d_type = inode_get_filetype(inode_p);

        if (!getbasename(directory_get_pathname(idx), dirp[i].d_name, NAME_MAX)) {
            int errsv = __get_errno();
            DEBUG_EXIT;
            __set_errno(errsv);
            return -1;
        }

        DEBUG_PRINT("(idx=%ld) -> '%s'\n", idx, dirp[i].d_name);
        idx = idx + 1;
    }
    if (idx != -1)  idx = directory_search(refname, idx);
    loc = (idx != -1)? index2loc(idx): -1;
    description_set_position(fd, loc);
    DEBUG_EXIT;
    return i * direntsize;
}

struct dirent* readdir0(DIR *dirp)
{
    for (;;) {
        if (dirp->dd_loc >= dirp->dd_size) {
            long dd_size = getdents0(dirp->dd_fd, (struct dirent *)dirp->dd_buf, dirp->dd_len);
            if (dd_size <= 0) break;
            dirp->dd_size = dd_size;
            dirp->dd_loc = 0;
        }
        struct dirent *dp = (struct dirent *)(dirp->dd_buf + dirp->dd_loc);
        if (dp->d_reclen <= 0 ||
            dp->d_reclen > (unsigned long)(dirp->dd_len + 1 - dirp->dd_loc)) break;
        dirp->dd_loc += dp->d_reclen;
        if (dirp->dd_loc >= dirp->dd_size) {
            dirp->dd_seek = lseek0(dirp->dd_fd, 0, SEEK_CUR);
        } else {
            dirp->dd_seek = ((struct dirent *)(dirp->dd_buf + dirp->dd_loc))->d_off;;
        }
        return dp;
    }
    return NULL;
}

void _seekdir0(DIR *dirp, long loc)
{
    if (dirp->dd_seek == loc) return;

    if (dirp->dd_loc > 0) {
        long dd_loc = 0;
        for (;;) {
            struct dirent *dp = (struct dirent *)(dirp->dd_buf + dd_loc);
            if (dp->d_reclen <= 0 ||
                dp->d_reclen > (unsigned long)(dirp->dd_len + 1 - dd_loc)) {
                break;
            }
            if (dp->d_off == loc) {
                dirp->dd_loc = dd_loc;
                dirp->dd_seek = loc;
                return;
            }
            dd_loc += dp->d_reclen;
            if (dd_loc > dirp->dd_size) break;
        }
    }

    if (loc < 0) loc = 0;
    if (loc2index(loc) > (long)filesystem->data.nfiles) return;

    long newpos = lseek0(dirp->dd_fd, loc, SEEK_SET);
    if (newpos != -1) {
        dirp->dd_seek = loc;
        dirp->dd_loc = dirp->dd_size;
    }
}

long telldir0(DIR *dirp)
{
    return dirp->dd_seek;
}

void _cleanupdir0(DIR *dirp)
{
    return;
}
static int chmod_common(inode_t *inode_p, mode_t mode)
{
    DEBUG_ENTRY;
    if (S_ISDIR(inode_get_mode(inode_p))) {
        DEBUG_PRINT("failed (not allowed to directories)\n");
        DEBUG_EXIT;
        __set_errno(EPERM);
        return -1;
    }
    mode_t mask = 0x1ff;
    mode_t workmode = inode_get_mode(inode_p);
    workmode &= ~mask;
    workmode |= (mode & mask);
    inode_set_mode(inode_p, workmode);
    DEBUG_EXIT;
    return 0;
}

int fchmodat0(int dirfd, const char *pathname, mode_t mode, int flags)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: pathname='%s' mode=%#o\n", pathname, mode);
    char buff[PATH_MAX];
    long idx = DIRECTORY_FINDAT(dirfd, pathname, buff, flags);
    inode_t *inode_p = DIRECTORY_GET_INODE(idx);
    int ret = chmod_common(inode_p, mode);
    DEBUG_PRINT("returns: %d\n", ret);
    DEBUG_EXIT;
    return ret;
}

static int fchmod0(int fd, mode_t mode)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d; mode=%#o\n", fd, mode);
    file_t *file = DESCRIPTION_GET_FILE(fd);
    int flags = openfile_get_flags(file);
    if (flags & O_PATH) {
        DEBUG_PRINT("failed (fd=%d open for O_PATH)\n", fd);
        DEBUG_EXIT;
        __set_errno(EBADF);
        return -1;
    }
    inode_t *inode_p = OPENFILE_GET_INODE(file);
    int ret = chmod_common(inode_p, mode);
    DEBUG_PRINT("returns: %d\n", ret);
    DEBUG_EXIT;
    return ret;
}
static int isatty0(int fd)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: fd=%d\n", fd);
    file_t *file = DESCRIPTION_GET_FILE(fd);
    inode_t *inode_p = OPENFILE_GET_INODE(file);
    mode_t mode = inode_get_mode(inode_p);
    char*  data = inode_get_data(inode_p);
    int ret = (S_ISCHR(mode) && data &&
                ((strcmp(data, STDIN_NAME) == 0) ||
                (strcmp(data, STDOUT_NAME) == 0) ||
                (strcmp(data, STDERR_NAME) == 0)));
    DEBUG_PRINT("returns: %d\n", ret);
    DEBUG_EXIT;
    return ret;
}
void _seekdir(DIR *dirp, long loc)
{
    return filesystem->oper._seekdir(dirp, loc);
}

void _cleanupdir(DIR *dirp)
{
    filesystem->oper._cleanupdir(dirp);
}

int access(const char *pathname, int mode)
{
    return filesystem->oper.faccessat(AT_FDCWD, pathname, mode, 0);
}

int chdir(const char *path)
{
    return filesystem->oper.chdir(path);
}

int chmod(const char *pathname, mode_t mode)
{
    return filesystem->oper.fchmodat(AT_FDCWD, pathname, mode, 0);
}

int close(int fd)
{
    return filesystem->oper.close(fd);
}

int creat(const char *pathname, mode_t mode)
{
    return filesystem->oper.openat(AT_FDCWD, pathname, O_CREAT|O_WRONLY|O_TRUNC, mode);
}

int dup(int oldfd)
{
    return filesystem->oper.dup(oldfd);
}

int dup2(int oldfd, int newfd)
{
    return filesystem->oper.dup2(oldfd, newfd);
}

int faccessat(int dirfd, const char *pathname, int mode, int flags)
{
    return filesystem->oper.faccessat(dirfd, pathname, mode, flags);
}

int fchdir(int fd)
{
    return filesystem->oper.fchdir(fd);
}

int fchmod(int fd, mode_t mode)
{
    return filesystem->oper.fchmod(fd, mode);
}

int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags)
{
    return filesystem->oper.fchmodat(dirfd, pathname, mode, flags);
}

int fcntl(int fd, int cmd, ...)
{
    va_list arg;
    va_start(arg, cmd);
    int res = filesystem->oper.fcntl(fd, cmd, arg);
    va_end(arg);
    return res;
}

int fdatasync(int fd)
{
    return filesystem->oper.fdatasync(fd);
}

int fstat(int fd, struct stat *st)
{
    return filesystem->oper.fstat(fd, st);
}

int fstatat(int dirfd, const char *pathname, struct stat *statbuf, int flags)
{
    return filesystem->oper.fstatat(dirfd, pathname, statbuf, flags);
}

int fsync(int fd)
{
    return filesystem->oper.fsync(fd);
}

int ftruncate(int fd, off_t length)
{
    return filesystem->oper.ftruncate(fd, length);
}

char* getcwd(char *buf, size_t size)
{
    return filesystem->oper.getcwd(buf, size);
}

long getdents(int fd, struct dirent *dirp, size_t count)
{
    return filesystem->oper.getdents(fd, dirp, count);
}

int ioctl(int fd, unsigned long request, ...)
{
    va_list arg;

    va_start(arg, request);
    int res = filesystem->oper.ioctl(fd, request, arg);
    va_end(arg);
    return res;
}

int isatty(int fd)
{
    return filesystem->oper.isatty(fd);
}

int link(const char *oldpath, const char *newpath)
{
    return filesystem->oper.linkat(AT_FDCWD, oldpath, AT_FDCWD, newpath, 0);
}

int linkat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags)
{
    return filesystem->oper.linkat(olddirfd, oldpath, newdirfd, newpath, flags);
}

off_t lseek(int file, off_t offset, int whence)
{
    return filesystem->oper.lseek(file, offset, whence);
}

int lstat(const char *pathname, struct stat *statbuf)
{
    return filesystem->oper.fstatat(AT_FDCWD, pathname, statbuf, AT_SYMLINK_NOFOLLOW);
}

int mkdir(const char *pathname, mode_t mode)
{
    return mkdirat(AT_FDCWD, pathname, mode);
}

int mkdirat(int dirfd, const char *pathname, mode_t mode)
{
    int dfd = filesystem->oper.openat(dirfd, pathname, O_RDONLY|O_DIRECTORY|O_CREAT|O_EXCL, mode);
    if (dfd == -1) return -1;
    close(dfd);
    return 0;
}

int open(const char *pathname, int flags, ...)
{
    int fd;
    if ((flags & O_CREAT) || (flags & O_TMPFILE)) {
        va_list arg;
        va_start(arg, flags);
        mode_t mode = va_arg(arg, mode_t);
        va_end(arg);
        fd = filesystem->oper.openat(AT_FDCWD, pathname, flags, mode);
    } else {
        fd = filesystem->oper.openat(AT_FDCWD, pathname, flags);
    }
    return fd;
}

int openat(int dirfd, const char *pathname, int flags, ...)
{
    int fd;
    if ((flags & O_CREAT) || (flags & O_TMPFILE)) {
        va_list arg;
        va_start(arg, flags);
        mode_t mode = va_arg(arg, mode_t);
        va_end(arg);
        fd = filesystem->oper.openat(dirfd, pathname, flags, mode);
    } else {
        fd = filesystem->oper.openat(dirfd, pathname, flags);
    }
    return fd;
}

ssize_t read(int fd, void *buf, size_t count)
{
    return filesystem->oper.read(fd, buf, count);
}

struct dirent* readdir(DIR *dirp)
{
    return filesystem->oper.readdir(dirp);
}

ssize_t readlink(const char *pathname, char *buf, size_t bufsiz)
{
    return filesystem->oper.readlinkat(AT_FDCWD, pathname, buf, bufsiz);
}

ssize_t readlinkat(int dirfd, const char *pathname, char *buf, size_t bufsiz)
{
    return filesystem->oper.readlinkat(dirfd, pathname, buf, bufsiz);
}

char* realpath(const char *path, char *resolved_path)
{
    return filesystem->oper.realpath(path, resolved_path);
}

int rename(const char *oldpath, const char *newpath)
{
    return filesystem->oper.renameat(AT_FDCWD, oldpath, AT_FDCWD, newpath);
}

int renameat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath)
{
    return filesystem->oper.renameat(olddirfd, oldpath, newdirfd, newpath);
}

int rmdir(const char *pathname)
{
    return filesystem->oper.unlinkat(AT_FDCWD, pathname, AT_REMOVEDIR);
}

int stat(const char *pathname, struct stat *statbuf)
{
    return filesystem->oper.fstatat(AT_FDCWD, pathname, statbuf, 0);
}

int symlink(const char *target, const char *linkpath)
{
    return filesystem->oper.symlinkat(target, AT_FDCWD, linkpath);
}

int symlinkat(const char *target, int newdirfd, const char *linkpath)
{
    return filesystem->oper.symlinkat(target, newdirfd, linkpath);
}

void seekdir(DIR *dirp, long loc)
{
    return filesystem->oper._seekdir(dirp, loc);
}

long telldir(DIR *dirp)
{
    return filesystem->oper.telldir(dirp);
}

int truncate(const char *path, off_t length)
{
    return filesystem->oper.truncate(path, length);
}

mode_t umask(mode_t mask)
{
    return filesystem->oper.umask(mask);
}

int unlink(const char *pathname)
{
    return filesystem->oper.unlinkat(AT_FDCWD, pathname, 0);
}

int unlinkat(int dirfd, const char *pathname, int flags)
{
    return filesystem->oper.unlinkat(dirfd, pathname, flags);
}

int utime(const char *filename, const struct utimbuf *times)
{
    return filesystem->oper.utime(filename, times);
}

int utimes(const char *filename, const struct timeval times[2])
{
    return filesystem->oper.utimes(filename, times);
}

size_t write(int fd, const void *buf, size_t count)
{
    return filesystem->oper.write(fd, buf, count);
}

#ifdef IVMFS_DUMPFILES
#ifdef IVMFS_DUMPFILECONTENTS
static unsigned long dump_file_content(char *pathname)
{
    FILE* fp = fopen(pathname, "r");
    unsigned long s = 0;
    if (fp){
        for (int ch = getc(fp); ch != EOF; ch = getc(fp)) {
            fputc(ch, stderr);
            s++;
        }
        fclose(fp);
    }
    return s;
}
#endif

static void dump_all_files(void)
{
    fflush(NULL);
    fprintf(stderr, "\n");
    for (long idx = 0; idx < filesystem->data.nfiles; idx++){
        char *pathname = directory_get_pathname(idx);
        if (!pathname) continue;
        inode_t *inode_p = directory_get_inode(idx);
        fprintf(stderr, "\n=======================================\n");
        if (!inode_p) {
            fprintf(stderr, "directory[%ld]: '%s' inode is nul\n", idx, pathname);
            fprintf(stderr, "=======================================\n");
            continue;
        }
        unsigned long size = inode_get_size(inode_p);
        fprintf(stderr, "directory[%ld]: '%s' %ld bytes\n",
              idx, pathname, size);
        fprintf(stderr, "=======================================\n");
        #ifdef IVMFS_DUMPFILECONTENTS
        mode_t mode = inode_get_mode(inode_p);
	if (S_ISREG(mode)) {
            dump_file_content(pathname);
        } else if (S_ISLNK(mode)) {
            char buff[PATH_MAX];
            int len = readlinkat0(AT_FDCWD, pathname, buff, PATH_MAX - 1);
            if (len == -1) continue;
            buff[len]='\0';
            fprintf(stderr, "%s\n", buff);
        }
        #endif
    }
}
#endif
int OPEN_STDIO(int stdfileno, char *device, int flags, char *name)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("query: df=%d, dev='%s', flags=%#x, name='%s'\n", stdfileno, device, flags, name);
    int fd = open(device, flags);
    if (fd == -1) {
        DEBUG_PRINT("Failed: char device '%s' not found\n", device);
    } else if (fd != stdfileno) {
        int badfd = fd;
        fd = dup2(badfd, stdfileno);
        if (fd != stdfileno) {
            DEBUG_PRINT("Failed to assign descriptor %d to %s, using fd=%d\n", stdfileno, name, badfd);
        }
        close(badfd);
    }
    DEBUG_PRINT("Done\n");
    DEBUG_EXIT;
    return fd;
}

static filesystem_file_t dup_fd(filesystem_file_t orig)
{
    DEBUG_ENTRY;
    DEBUG_PRINT("Duplicating fd vector (tam=%ld file_t*)\n", orig.size);
    file_t **fd = (file_t **)malloc(orig.size * sizeof(file_t *));
    for (unsigned long i = 0; i < orig.size; i++) {
        file_t *file = orig.fd[i];
        fd[i] = file;
        if (file) {
            DEBUG_PRINT("[%ld] %p\n", file);
            openfile_link(file);
            directory_link(openfile_get_directory_entry(file));
        }
    }
    DEBUG_PRINT("Done\n");
    DEBUG_EXIT;
    return (filesystem_file_t){ size:orig.size, fd:fd };
}

static void close_all()
{
    DEBUG_ENTRY;
    DEBUG_PRINT("Flushing and closing all files fd from: %d to: %d\n", 0, filesystem->fd.size-1);
    for (unsigned long fd = 0; fd < filesystem->fd.size; fd++) {
        close(fd);
    }
    DEBUG_EXIT;
}

static void init_tty()
{
    struct termios t;
    memset(&t, 0, sizeof(t));
    t.c_lflag |= ICANON;
    t.c_lflag |= ECHO;
    t.c_cc[VMIN] = 1;
    t.c_cc[VTIME] = 0;
    ioctl(STDIN_FILENO, TCSETS, &t);
}

static filesystem_file_t ivm_crt0_fd_backup = { size:0, fd:NULL };
static int *ivm_crt0_errno_p = &errno0;
static char ivm_crt0_cwd[PATH_MAX];

long __IVM64_ivmfs_started__ = 0;

__attribute__ ((constructor(110)))
void __IVMFS_start__()
{
    DEBUG_ENTRY;
    DEBUG_PRINT("IVMFS begins ...\n");

    __IVM64_ivmfs_started__++;
    if (__IVM64_ivmfs_started__ != 1) return;

    void *newfs = NULL;
    char *newFSstr = getenv("IVM_CRT0_FILESYSTEM");
    if (newFSstr) {
        newfs = (void*)(unsigned long)strtol(newFSstr, NULL, 16);
        DEBUG_PRINT("IVM_CRT0_FILESYSTEM='%s' (%p)\n",newFSstr, newfs);
    }
    if (newfs) {
        fflush(stdout);
        fflush(stderr);
        filesystem = (filesystem_t*) newfs;
        ivm_crt0_errno_p = filesystem->errno_p;
        filesystem->errno_p = &errno;
        ivm_crt0_fd_backup = dup_fd(filesystem->fd);
        init_tty();
        DEBUG_PRINT("Frogot own filesystem, new one is inherited: %p (ptr)\n", newfs);
    } else {
        DEBUG_PRINT("Keeping OWN filesystem: %p\n", filesystem);
        filesystem->data.nfiles = ${GLOBAL_NFILES};
        filesystem->errno_p = &errno;
        char fsno[20];
        snprintf(fsno, 20, "%#lx", (unsigned long)filesystem);
        setenv("IVM_CRT0_FILESYSTEM", fsno, 1);
        OPEN_STDIO(STDIN_FILENO,  (char*)STDIN_DEVICE,  O_RDONLY, (char*)STDIN_NAME);
        OPEN_STDIO(STDOUT_FILENO, (char*)STDOUT_DEVICE, O_WRONLY, (char*)STDOUT_NAME);
        OPEN_STDIO(STDERR_FILENO, (char*)STDERR_DEVICE, O_WRONLY, (char*)STDERR_NAME);
        init_tty();
        int fd = open((char*)STDIN_FILENAME, O_RDONLY);
        if (fd != -1) {
            dup2(fd, STDIN_FILENO);
            close(fd);
        }
        #ifdef IVMFS_DEBUG
        if (fd >= 0) {
            DEBUG_PRINT("Using file '%s' as stdin\n", STDIN_FILENAME);
        }
        #endif
        setenv("HOME", IVMFSROOT, 1);
        chdir(IVMFSROOT);
    }
    setenv("LC_ALL", "C.UTF-8", 1);
    getcwd(ivm_crt0_cwd, PATH_MAX);
    DEBUG_PRINT("IVMFS ready\n");
    DEBUG_EXIT;
}

__attribute__ ((destructor(110)))
void __IVMFS_end__()
{
    __IVM64_ivmfs_started__--;
    if (__IVM64_ivmfs_started__) return;

    DEBUG_ENTRY;
    DEBUG_PRINT("IVMFS umount\n");
    #ifdef IVMFS_DUMPFILES
    dump_all_files();
    #endif
    close_all();
    DEBUG_PRINT("Recovering fd vector (original size=%d, current size=%d)\n", ivm_crt0_fd_backup.size, filesystem->fd.size);
    memcpy(filesystem->fd.fd, ivm_crt0_fd_backup.fd, ivm_crt0_fd_backup.size * sizeof(file_t *));
    free(ivm_crt0_fd_backup.fd);
    filesystem->errno_p = ivm_crt0_errno_p;
    chdir(ivm_crt0_cwd);
    DEBUG_PRINT("IVMFS ends ...\n");
    DEBUG_EXIT;
}
#ifdef __cplusplus
}
#endif

#endif

EEOOFF
}

#--------------------
init
parse_args "$@"
if ! printing_asm ; then
    print_header
    print_preamble
    print_files "$@"
    print_structure
else
    shift 2 # -o object
    print_files "$@"                    >  "$IVMFS_OUT_OBJ"
    print_header | gawk '{print "#"$0}' >> "$IVMFS_OUT_OBJ"
fi
